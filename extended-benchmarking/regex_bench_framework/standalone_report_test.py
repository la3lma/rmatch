#!/usr/bin/env python3
"""Standalone test for report generator."""

import json
import time
from pathlib import Path
from datetime import datetime

def generate_html_report(data, output_dir):
    """Generate HTML report from benchmark data."""
    summary = data.get('summary', {})
    raw_results = data.get('raw_results', [])

    # Create simple HTML report
    html = f"""<!DOCTYPE html>
<html>
<head>
    <title>Regex Benchmark Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        .header {{ text-align: center; margin-bottom: 30px; }}
        .summary {{ background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; }}
        .results {{ margin-top: 20px; }}
        table {{ width: 100%; border-collapse: collapse; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background-color: #f2f2f2; }}
        .success {{ color: green; }}
        .error {{ color: red; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ Regex Benchmark Report</h1>
        <p>Run ID: {summary.get('run_id', 'Unknown')} | Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>

    <div class="summary">
        <h2>üìä Summary</h2>
        <p><strong>Phase:</strong> {str(summary.get('phase', 'unknown')).title()}</p>
        <p><strong>Status:</strong> <span class="{'success' if summary.get('status') == 'completed' else 'error'}">{str(summary.get('status', 'unknown')).title()}</span></p>
        <p><strong>Duration:</strong> {summary.get('duration_seconds', 0):.2f} seconds</p>
        <p><strong>Engines:</strong> {', '.join(summary.get('engines_tested', []))}</p>
        <p><strong>Total Runs:</strong> {summary.get('total_combinations', 0)}</p>
        <p><strong>Successful Runs:</strong> {summary.get('successful_runs', 0)}</p>
        <p><strong>Success Rate:</strong> {(summary.get('successful_runs', 0) / max(summary.get('total_combinations', 1), 1) * 100):.1f}%</p>
    </div>

    <div class="results">
        <h2>üìã Detailed Results</h2>
        <table>
            <thead>
                <tr>
                    <th>#</th>
                    <th>Engine</th>
                    <th>Status</th>
                    <th>Corpus Size</th>
                    <th>Compilation (ms)</th>
                    <th>Scanning (ms)</th>
                    <th>Throughput</th>
                    <th>Matches</th>
                    <th>Patterns</th>
                </tr>
            </thead>
            <tbody>"""

    for i, result in enumerate(raw_results):
        comp_ms = ((result.get('compilation_ns') or 0) / 1_000_000)
        scan_ms = ((result.get('scanning_ns') or 0) / 1_000_000)
        status_class = 'success' if result.get('status') == 'ok' else 'error'

        # Calculate corpus size and MB/sec throughput
        corpus_size_bytes = result.get('corpus_size_bytes') or 0
        corpus_size_mb = corpus_size_bytes / (1024 * 1024) if corpus_size_bytes and corpus_size_bytes > 0 else 0

        # Calculate MB/sec scanning throughput
        scanning_ns = result.get('scanning_ns') or 0
        mb_per_sec = 0
        if scanning_ns and scanning_ns > 0 and corpus_size_bytes and corpus_size_bytes > 0:
            scanning_seconds = scanning_ns / 1_000_000_000  # Convert nanoseconds to seconds
            mb_per_sec = corpus_size_mb / scanning_seconds

        html += f"""
                <tr>
                    <td>{i + 1}</td>
                    <td>{result.get('engine_name', 'Unknown')}</td>
                    <td class="{status_class}">{result.get('status', 'unknown')}</td>
                    <td>{corpus_size_mb:.1f} MB</td>
                    <td>{comp_ms:.3f}</td>
                    <td>{scan_ms:.3f}</td>
                    <td>{mb_per_sec:.2f} MB/sec</td>
                    <td>{result.get('match_count', 0)}</td>
                    <td>{result.get('patterns_compiled', 0)}</td>
                </tr>"""

    html += """
            </tbody>
        </table>
    </div>

    <footer style="margin-top: 40px; text-align: center; color: #666; font-size: 14px;">
        <p>Generated by Regex Bench Framework v2.0</p>
    </footer>
</body>
</html>"""

    # Write report file
    report_file = output_dir / "benchmark_report.html"
    with open(report_file, 'w') as f:
        f.write(html)

    return report_file

def main():
    # Test with latest results
    results_dir = Path("results/quick_20251219_140928")
    output_dir = Path("test_reports")

    if not results_dir.exists():
        print(f"‚ùå Results directory not found: {results_dir}")
        return

    print(f"üìä Generating report from: {results_dir}")

    # Load data
    data = {}

    # Load summary
    summary_file = results_dir / "summary.json"
    if summary_file.exists():
        with open(summary_file, 'r') as f:
            data['summary'] = json.load(f)
        print("‚úì Loaded summary data")

    # Load raw results
    raw_results_file = results_dir / "raw_results" / "benchmark_results.json"
    if raw_results_file.exists():
        with open(raw_results_file, 'r') as f:
            data['raw_results'] = json.load(f)
        print(f"‚úì Loaded {len(data['raw_results'])} raw results")

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)

    # Generate report
    try:
        report_file = generate_html_report(data, output_dir)
        print(f"‚úÖ HTML report generated: {report_file}")

        # Show some stats
        summary = data.get('summary', {})
        print(f"üìà Report highlights:")
        print(f"   ‚Ä¢ Run ID: {summary.get('run_id', 'Unknown')}")
        print(f"   ‚Ä¢ Engines: {', '.join(summary.get('engines_tested', []))}")
        print(f"   ‚Ä¢ Success Rate: {(summary.get('successful_runs', 0) / max(summary.get('total_combinations', 1), 1) * 100):.1f}%")
        print(f"   ‚Ä¢ Duration: {summary.get('duration_seconds', 0):.2f} seconds")

    except Exception as e:
        print(f"‚ùå Report generation failed: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()