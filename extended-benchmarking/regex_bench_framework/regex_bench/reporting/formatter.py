"""
Report formatters for different output formats.
"""

import json
import time
from pathlib import Path
from typing import Dict, Any, List
from datetime import datetime


class HTMLFormatter:
    """Generate HTML reports with interactive features."""

    def generate_report(
        self,
        data: Dict[str, Any],
        output_dir: Path,
        include_charts: bool = False
    ) -> Path:
        """Generate an HTML report."""

        # Generate report content
        html_content = self._generate_html_report(data, include_charts)

        # Write report file
        report_file = output_dir / "benchmark_report.html"
        with open(report_file, 'w') as f:
            f.write(html_content)

        # Copy any assets if needed
        self._copy_assets(output_dir)

        return report_file

    def _generate_html_report(self, data: Dict[str, Any], include_charts: bool) -> str:
        """Generate the complete HTML report content."""

        summary = data.get('summary', {})
        raw_results = data.get('raw_results', [])
        analysis = data.get('analysis', {})
        metadata = data.get('metadata', {})

        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regex Benchmark Report - {summary.get('run_id', 'Unknown')}</title>
    <style>
        {self._get_css_styles()}
    </style>
    {self._get_chart_scripts() if include_charts else ''}
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸš€ Regex Benchmark Report</h1>
            <div class="metadata">
                <span class="run-id">Run ID: {summary.get('run_id', 'Unknown')}</span>
                <span class="timestamp">Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</span>
            </div>
        </header>

        {self._generate_summary_section(summary, analysis)}
        {self._generate_engines_section(raw_results)}
        {self._generate_results_section(raw_results, analysis)}
        {self._generate_performance_section(analysis)}
        {'    ' + self._generate_charts_section(raw_results, analysis) if include_charts else ''}
        {self._generate_raw_data_section(raw_results)}

        <footer>
            <p>Generated by Regex Bench Framework v2.0 â€¢ <a href="https://github.com/anthropics/claude-code">Powered by Claude Code</a></p>
        </footer>
    </div>
</body>
</html>"""

        return html

    def _generate_summary_section(self, summary: Dict[str, Any], analysis: Dict[str, Any] = None) -> str:
        """Generate the summary section with throughput statistics."""
        phase = str(summary.get('phase', 'unknown'))
        status = str(summary.get('status', 'unknown'))
        engines_tested = summary.get('engines_tested', [])
        engines = ', '.join([str(e) for e in engines_tested]) if engines_tested else 'None'
        total = int(summary.get('total_combinations', 0))
        successful = int(summary.get('successful_runs', 0))
        failed = int(summary.get('failed_runs', 0))
        duration = float(summary.get('duration_seconds', 0))

        status_class = 'status-success' if status.lower() == 'completed' else 'status-error'

        # Build main summary cards
        summary_cards = f"""
                <div class="summary-card">
                    <div class="card-label">Phase</div>
                    <div class="card-value">{phase.title()}</div>
                </div>
                <div class="summary-card">
                    <div class="card-label">Status</div>
                    <div class="card-value {status_class}">{status.title()}</div>
                </div>
                <div class="summary-card">
                    <div class="card-label">Duration</div>
                    <div class="card-value">{duration:.2f}s</div>
                </div>
                <div class="summary-card">
                    <div class="card-label">Engines Tested</div>
                    <div class="card-value">{engines}</div>
                </div>
                <div class="summary-card">
                    <div class="card-label">Total Runs</div>
                    <div class="card-value">{total}</div>
                </div>
                <div class="summary-card">
                    <div class="card-label">Success Rate</div>
                    <div class="card-value">{(successful/max(total,1)*100):.1f}%</div>
                </div>"""

        # Add throughput statistics if available
        throughput_section = ""
        if analysis and 'summary' in analysis and 'throughput_summary' in analysis['summary']:
            throughput_data = analysis['summary']['throughput_summary']
            if throughput_data:
                throughput_section = """
            <div class="throughput-summary">
                <h3>ğŸš€ Throughput Performance Summary</h3>
                <div class="throughput-grid">"""

                for engine_name, stats in throughput_data.items():
                    throughput_section += f"""
                    <div class="throughput-card">
                        <h4>{engine_name}</h4>
                        <div class="throughput-stats">
                            <div class="stat-item">
                                <span class="stat-label">Average:</span>
                                <span class="stat-value">{stats['average_mean_mbps']:.2f} MB/s</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Median:</span>
                                <span class="stat-value">{stats['average_median_mbps']:.2f} MB/s</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Std Dev:</span>
                                <span class="stat-value">{stats['average_std_dev_mbps']:.2f} MB/s</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Peak:</span>
                                <span class="stat-value">{stats['best_mean_mbps']:.2f} MB/s</span>
                            </div>
                        </div>
                    </div>"""

                throughput_section += """
                </div>
            </div>"""

        return f"""
        <section class="summary">
            <h2>ğŸ“Š Benchmark Summary</h2>
            <div class="summary-grid">
                {summary_cards}
            </div>
            {throughput_section}
        </section>"""

    def _generate_engines_section(self, raw_results: List[Dict[str, Any]]) -> str:
        """Generate the engines overview section."""
        # Group results by engine
        engines = {}
        for result in raw_results:
            engine_name = result.get('engine_name', 'unknown')
            if engine_name not in engines:
                engines[engine_name] = {
                    'name': engine_name,
                    'runs': 0,
                    'successful_runs': 0,
                    'avg_compilation_ns': 0,
                    'avg_scanning_ns': 0,
                    'total_matches': 0
                }

            engines[engine_name]['runs'] += 1
            if result.get('status') == 'ok':
                engines[engine_name]['successful_runs'] += 1
                engines[engine_name]['avg_compilation_ns'] += result.get('compilation_ns', 0)
                engines[engine_name]['avg_scanning_ns'] += result.get('scanning_ns', 0)
                engines[engine_name]['total_matches'] += result.get('match_count', 0)

        # Calculate averages
        for engine in engines.values():
            if engine['successful_runs'] > 0:
                engine['avg_compilation_ns'] //= engine['successful_runs']
                engine['avg_scanning_ns'] //= engine['successful_runs']

        engine_rows = ""
        for engine in engines.values():
            success_rate = (engine['successful_runs'] / max(engine['runs'], 1)) * 100
            engine_rows += f"""
                <tr>
                    <td class="engine-name">{engine['name']}</td>
                    <td>{engine['runs']}</td>
                    <td>{success_rate:.1f}%</td>
                    <td>{engine['avg_compilation_ns']:,} ns</td>
                    <td>{engine['avg_scanning_ns']:,} ns</td>
                    <td>{engine['total_matches']}</td>
                </tr>"""

        return f"""
        <section class="engines">
            <h2>ğŸ”§ Engine Performance Overview</h2>
            <div class="table-container">
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Engine</th>
                            <th>Total Runs</th>
                            <th>Success Rate</th>
                            <th>Avg Compilation</th>
                            <th>Avg Scanning</th>
                            <th>Total Matches</th>
                        </tr>
                    </thead>
                    <tbody>
                        {engine_rows}
                    </tbody>
                </table>
            </div>
        </section>"""

    def _generate_results_section(self, raw_results: List[Dict[str, Any]], analysis: Dict[str, Any]) -> str:
        """Generate detailed results section."""
        if not raw_results:
            return "<section><h2>ğŸ“‹ Results</h2><p>No results available.</p></section>"

        result_rows = ""
        for i, result in enumerate(raw_results):
            status_class = 'status-success' if result.get('status') == 'ok' else 'status-error'
            compilation_ms = ((result.get('compilation_ns') or 0) / 1_000_000)
            scanning_ms = ((result.get('scanning_ns') or 0) / 1_000_000)

            # Calculate corpus size and MB/sec throughput
            corpus_size_bytes = result.get('corpus_size_bytes') or 0
            corpus_size_mb = corpus_size_bytes / (1024 * 1024) if corpus_size_bytes and corpus_size_bytes > 0 else 0

            # Calculate MB/sec scanning throughput
            scanning_ns = result.get('scanning_ns') or 0
            mb_per_sec = 0
            if scanning_ns and scanning_ns > 0 and corpus_size_bytes and corpus_size_bytes > 0:
                scanning_seconds = scanning_ns / 1_000_000_000  # Convert nanoseconds to seconds
                mb_per_sec = corpus_size_mb / scanning_seconds

            # Calculate pattern processing rate (regex/sec)
            patterns_per_sec_display = "-"
            patterns_compiled = result.get('patterns_compiled', 0)
            if scanning_ns and scanning_ns > 0 and patterns_compiled and patterns_compiled > 0:
                scanning_seconds = scanning_ns / 1_000_000_000  # Convert nanoseconds to seconds
                patterns_per_sec = patterns_compiled / scanning_seconds
                if patterns_per_sec >= 1000:
                    patterns_per_sec_display = f"{patterns_per_sec/1000:.1f}K/sec"
                else:
                    patterns_per_sec_display = f"{patterns_per_sec:.1f}/sec"

            # Calculate total pattern throughput (patterns Ã— MB/sec)
            total_throughput_display = "-"
            if scanning_ns and scanning_ns > 0 and patterns_compiled and patterns_compiled > 0 and corpus_size_mb > 0:
                scanning_seconds = scanning_ns / 1_000_000_000  # Convert nanoseconds to seconds
                total_throughput = (patterns_compiled * corpus_size_mb) / scanning_seconds
                if total_throughput >= 1000:
                    total_throughput_display = f"{total_throughput/1000:.1f}K pâ‹…MB/s"
                else:
                    total_throughput_display = f"{total_throughput:.1f} pâ‹…MB/s"

            result_rows += f"""
                <tr class="result-row">
                    <td>{i + 1}</td>
                    <td>{result.get('engine_name', 'Unknown')}</td>
                    <td>{result.get('iteration', 0)}</td>
                    <td class="{status_class}">{result.get('status', 'unknown')}</td>
                    <td>{corpus_size_mb:.1f} MB</td>
                    <td>{compilation_ms:.3f}</td>
                    <td>{scanning_ms:.3f}</td>
                    <td>{mb_per_sec:.2f} MB/sec</td>
                    <td>{result.get('match_count', 0)}</td>
                    <td>{result.get('patterns_compiled', 0)}</td>
                    <td>{patterns_per_sec_display}</td>
                    <td>{total_throughput_display}</td>
                </tr>"""

        return f"""
        <section class="detailed-results">
            <h2>ğŸ“‹ Detailed Results</h2>
            <div class="table-container">
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Engine</th>
                            <th>Iteration</th>
                            <th>Status</th>
                            <th>Corpus Size</th>
                            <th>Compilation (ms)</th>
                            <th>Scanning (ms)</th>
                            <th>Throughput</th>
                            <th>Matches</th>
                            <th>Patterns</th>
                            <th>Regex/sec</th>
                            <th>Total Throughput</th>
                        </tr>
                    </thead>
                    <tbody>
                        {result_rows}
                    </tbody>
                </table>
            </div>
        </section>"""

    def _generate_performance_section(self, analysis: Dict[str, Any]) -> str:
        """Generate performance analysis section."""
        grouped_stats = analysis.get('grouped_statistics', {})
        comparisons = analysis.get('comparisons', {})

        if not grouped_stats:
            return "<section><h2>âš¡ Performance Analysis</h2><p>No analysis data available.</p></section>"

        stats_content = ""
        for group_key, stats in grouped_stats.items():
            engine_name = stats.get('engine_name', 'Unknown')
            patterns = stats.get('patterns_compiled', 0)
            corpus_size = stats.get('corpus_size_bytes', 0)

            # Get scanning statistics
            scanning = stats.get('scanning', {})
            if scanning:
                mean_ms = (scanning.get('mean') or 0) / 1_000_000
                median_ms = (scanning.get('median') or 0) / 1_000_000
                std_ms = (scanning.get('std_dev') or 0) / 1_000_000

                stats_content += f"""
                <div class="performance-card">
                    <h4>{engine_name}</h4>
                    <div class="perf-details">
                        <div class="perf-item">
                            <span class="label">Patterns:</span>
                            <span class="value">{patterns}</span>
                        </div>
                        <div class="perf-item">
                            <span class="label">Corpus Size:</span>
                            <span class="value">{corpus_size:,} bytes</span>
                        </div>
                        <div class="perf-item">
                            <span class="label">Mean Scan Time:</span>
                            <span class="value">{mean_ms:.3f} ms</span>
                        </div>
                        <div class="perf-item">
                            <span class="label">Median Scan Time:</span>
                            <span class="value">{median_ms:.3f} ms</span>
                        </div>
                        <div class="perf-item">
                            <span class="label">Std Deviation:</span>
                            <span class="value">{std_ms:.3f} ms</span>
                        </div>
                    </div>
                </div>"""

        return f"""
        <section class="performance">
            <h2>âš¡ Performance Analysis</h2>
            <div class="performance-grid">
                {stats_content}
            </div>
        </section>"""

    def _generate_charts_section(self, raw_results: List[Dict[str, Any]], analysis: Dict[str, Any]) -> str:
        """Generate charts section (placeholder for now)."""
        return """
        <section class="charts">
            <h2>ğŸ“ˆ Performance Charts</h2>
            <div class="chart-placeholder">
                <p>ğŸ“Š Interactive charts would be displayed here when chart dependencies are available.</p>
                <p>Charts would include: throughput comparisons, compilation time distributions, and performance trends.</p>
            </div>
        </section>"""

    def _generate_raw_data_section(self, raw_results: List[Dict[str, Any]]) -> str:
        """Generate raw data section."""
        return f"""
        <section class="raw-data">
            <h2>ğŸ” Raw Data</h2>
            <details>
                <summary>Click to expand raw benchmark data</summary>
                <pre class="raw-json">{json.dumps(raw_results, indent=2)}</pre>
            </details>
        </section>"""

    def _get_css_styles(self) -> str:
        """Get CSS styles for the HTML report."""
        return """
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        header h1 {
            margin: 0;
            color: #2c3e50;
        }
        .metadata {
            margin-top: 10px;
            color: #666;
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        section {
            background: white;
            margin: 20px 0;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .summary-card {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }
        .card-label {
            font-size: 12px;
            text-transform: uppercase;
            color: #666;
            margin-bottom: 5px;
        }
        .card-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        .status-success {
            color: #27ae60 !important;
        }
        .status-error {
            color: #e74c3c !important;
        }
        .table-container {
            overflow-x: auto;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }
        .results-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }
        .results-table tr:hover {
            background: #f8f9fa;
        }
        .engine-name {
            font-weight: 600;
            color: #3498db;
        }
        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .performance-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            border-left: 4px solid #9b59b6;
        }
        .throughput-summary {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .throughput-summary h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }
        .throughput-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }
        .throughput-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            border-left: 4px solid #e74c3c;
        }
        .throughput-card h4 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-weight: 600;
            text-align: center;
        }
        .throughput-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ecf0f1;
        }
        .stat-label {
            color: #666;
            font-weight: 500;
        }
        .stat-value {
            color: #2c3e50;
            font-weight: 700;
            font-size: 14px;
        }
        .performance-card h4 {
            margin: 0 0 15px 0;
            color: #2c3e50;
        }
        .perf-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
        }
        .perf-item .label {
            color: #666;
        }
        .perf-item .value {
            font-weight: 600;
        }
        .chart-placeholder {
            text-align: center;
            padding: 40px;
            background: #f8f9fa;
            border-radius: 6px;
            color: #666;
        }
        .raw-json {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
            white-space: pre-wrap;
        }
        footer {
            text-align: center;
            margin-top: 40px;
            color: #666;
            font-size: 14px;
        }
        footer a {
            color: #3498db;
            text-decoration: none;
        }
        """

    def _get_chart_scripts(self) -> str:
        """Get chart library scripts (placeholder)."""
        return """
        <!-- Chart.js would be included here -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        """

    def _copy_assets(self, output_dir: Path) -> None:
        """Copy any additional assets needed for the report."""
        # Placeholder for copying CSS, JS, images, etc.
        pass


class MarkdownFormatter:
    """Generate Markdown reports."""

    def generate_report(
        self,
        data: Dict[str, Any],
        output_dir: Path,
        include_charts: bool = False
    ) -> Path:
        """Generate a Markdown report."""

        summary = data.get('summary', {})
        raw_results = data.get('raw_results', [])
        analysis = data.get('analysis', {})

        markdown = f"""# ğŸš€ Regex Benchmark Report

**Run ID:** {summary.get('run_id', 'Unknown')}
**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## ğŸ“Š Summary

- **Phase:** {str(summary.get('phase', 'unknown')).title()}
- **Status:** {str(summary.get('status', 'unknown')).title()}
- **Duration:** {summary.get('duration_seconds', 0):.2f}s
- **Engines:** {', '.join(summary.get('engines_tested', []))}
- **Total Runs:** {summary.get('total_combinations', 0)}
- **Success Rate:** {(summary.get('successful_runs', 0) / max(summary.get('total_combinations', 1), 1) * 100):.1f}%

## ğŸ”§ Results

| Engine | Status | Compilation (ms) | Scanning (ms) | Matches | Patterns | Regex/sec | Total Throughput |
|--------|--------|------------------|---------------|---------|----------|-----------|------------------|
"""

        for result in raw_results[:10]:  # Show first 10 results
            comp_ms = ((result.get('compilation_ns') or 0) / 1_000_000)
            scan_ms = ((result.get('scanning_ns') or 0) / 1_000_000)

            # Calculate pattern processing rate (regex/sec)
            patterns_per_sec_display = "-"
            patterns_compiled = result.get('patterns_compiled', 0)
            scanning_ns = result.get('scanning_ns', 0)
            if scanning_ns and scanning_ns > 0 and patterns_compiled and patterns_compiled > 0:
                scanning_seconds = scanning_ns / 1_000_000_000  # Convert nanoseconds to seconds
                patterns_per_sec = patterns_compiled / scanning_seconds
                if patterns_per_sec >= 1000:
                    patterns_per_sec_display = f"{patterns_per_sec/1000:.1f}K/sec"
                else:
                    patterns_per_sec_display = f"{patterns_per_sec:.1f}/sec"

            # Calculate total pattern throughput (patterns Ã— MB/sec)
            total_throughput_display = "-"
            corpus_size_bytes = result.get('corpus_size_bytes', 0)
            corpus_size_mb = corpus_size_bytes / (1024 * 1024) if corpus_size_bytes and corpus_size_bytes > 0 else 0
            if scanning_ns and scanning_ns > 0 and patterns_compiled and patterns_compiled > 0 and corpus_size_mb > 0:
                scanning_seconds = scanning_ns / 1_000_000_000  # Convert nanoseconds to seconds
                total_throughput = (patterns_compiled * corpus_size_mb) / scanning_seconds
                if total_throughput >= 1000:
                    total_throughput_display = f"{total_throughput/1000:.1f}K pâ‹…MB/s"
                else:
                    total_throughput_display = f"{total_throughput:.1f} pâ‹…MB/s"

            markdown += f"| {result.get('engine_name', 'Unknown')} | {result.get('status', 'unknown')} | {comp_ms:.3f} | {scan_ms:.3f} | {result.get('match_count', 0)} | {result.get('patterns_compiled', 0)} | {patterns_per_sec_display} | {total_throughput_display} |\n"

        if len(raw_results) > 10:
            markdown += f"\n*... and {len(raw_results) - 10} more results*\n"

        markdown += f"""

## ğŸ“„ Raw Data

```json
{json.dumps(summary, indent=2)}
```

---
*Generated by Regex Bench Framework v2.0*"""

        # Write markdown file
        report_file = output_dir / "benchmark_report.md"
        with open(report_file, 'w') as f:
            f.write(markdown)

        return report_file