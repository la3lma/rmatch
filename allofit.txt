/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.mockedcompiler;

import static com.google.common.base.Preconditions.checkNotNull;
import java.util.Map;
import no.rmz.rmatch.interfaces.NDFACompiler;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.Regexp;
import no.rmz.rmatch.interfaces.RegexpStorage;

/**
 * A compiler that can be primed with predigested compilation results, enabling
 * it to compile known regular expressions into known NDFAnodes representing
 * them.
 */
public final class MockerCompiler implements NDFACompiler {

    /**
     * A map of mocked compilation results.
     */
    private final Map<Regexp, NDFANode> mockedCompilationResult;

    /**
     * Make a new instance, with a particular map for holding the results.
     * @param mockedCompilationResult the result that will used by
     *        this "compiler" to look up its
     *        result of compilation.
     */
    public MockerCompiler(final Map<Regexp, NDFANode> mockedCompilationResult) {
        this.mockedCompilationResult = checkNotNull(mockedCompilationResult);
    }

    @Override
    public NDFANode compile(
            final Regexp regexp,
            final RegexpStorage rs) {

        checkNotNull(regexp);
        checkNotNull(rs);

        if (mockedCompilationResult.containsKey(regexp)) {
            return mockedCompilationResult.get(regexp);
        } else {
            throw new IllegalArgumentException(
                    "Attempt to compile something that isn't already compiled");
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.mockedcompiler;

import no.rmz.rmatch.compiler.CharNode;
import no.rmz.rmatch.compiler.TerminalNode;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.Regexp;

/**
 * A simple compiler for character sequences only to be used during testing.
 */
public final class CharSequenceCompiler {

    /**
     * Compile a string to represent a regexp as part of a Regexp instance.
     *
     * @param regexp the regexp we're part of
     * @param str the string that should be compiled.
     * @return The entry point for the compiled regexp string.
     */
    public static NDFANode compile(final Regexp regexp, final String str) {
        NDFANode result = new TerminalNode(regexp);
        for (int i = str.length() - 1; i >= 0; i--) {
            final Character myChar = str.charAt(i);
            result = new CharNode(result, myChar, regexp);
        }

        return result;
    }

    /**
     * This is an utility class so no public constructor.
     */
    private CharSequenceCompiler() {
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.mockedcompiler;

import static com.google.common.base.Preconditions.checkNotNull;
import java.util.Collection;
import no.rmz.rmatch.abstracts.AbstractNDFANode;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.PrintableEdge;
import no.rmz.rmatch.interfaces.Regexp;

/**
 * A node, used for testing, that will recognize a single or more instances of a
 * particular character.
 */
public final class CharPlusNode extends AbstractNDFANode {

    /**
     * The character that will be recognized.
     */
    private final Character myChar;

    /**
     * Create a new CharPlusNode instance.
     *
     * @param ch The character that will be recognized.
     * @param r The regular expression that this node is representing.
     * @param isTerminal True iff this node represents legal terminations of the
     * regexp r.
     */
    public CharPlusNode(
            final Character ch,
            final Regexp r,
            final boolean isTerminal) {
        super(r, isTerminal);
        this.myChar = checkNotNull(ch, "char can't be null");
    }

    @Override
    public NDFANode getNextNDFA(final Character ch) {
        if (ch.equals(myChar)) {
            return this;
        } else {
            return null;
        }
    }

    @Override
    public Collection<PrintableEdge> getEdgesToPrint() {
        synchronized (monitor) {
            final Collection<PrintableEdge> result = getEpsilonEdgesToPrint();
            result.add(new PrintableEdge(String.valueOf(myChar), this));
            return result;
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.impls;

import no.rmz.rmatch.interfaces.DFANode;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.NodeStorage;
import no.rmz.rmatch.interfaces.PrintableEdge;
import no.rmz.rmatch.utils.SortedSetComparatorImpl;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * Implement the subset construction mechanism, but also keep track of a
 * "StartNode" NDFA node that has the particular property that it is always
 * present, and all NDFAs that are added to the storage can be reached from the
 * startnode via an epsilon edge.
 */
public final class NodeStorageImpl implements NodeStorage {

    /**
     * A comparator for ordered sets of NDFA Nodes that will deem a set larger
     * than the other by finding the first element (as defined by the ordering
     * of the sets) that is different. A comparison of the differing element
     * determines the ordering of the sets.
     */
    private static final Comparator<SortedSet<NDFANode>>
            SORTED_NDFANODE_SET_COMPARATOR =
                    new SortedSetComparatorImpl<>();
    /**
     * There is only one start node, and this is that node.
     */
    private final StartNode sn;
    /**
     * A map mapping sorted sets of NDFANodes into DFAnodes. Used to map sets of
     * NDFANodes to previously compiled DFAnodes representing that set of
     * NDFANodes.
     */
    private final Map<SortedSet<NDFANode>, DFANode> ndfamap =
                new TreeMap<>(SORTED_NDFANODE_SET_COMPARATOR);

    /**
     * Create a new instance of the node storage.
     */
    public NodeStorageImpl() {
        sn = new StartNode(this);
    }

    @Override
    public Collection<NDFANode> getNDFANodes() {
        synchronized (ndfamap) {
            final Set<NDFANode> result = new HashSet<>();
            final Set<NDFANode> unexplored = new ConcurrentSkipListSet<>();
            unexplored.add(sn);

            while (!unexplored.isEmpty()) {

                final NDFANode current = unexplored.iterator().next();
                unexplored.remove(current);
                if (!result.contains(current)) {
                    result.add(current);
                    final Set<NDFANode> connectedNodes =
                            new HashSet<>(current.getEpsilons());
                    for (final PrintableEdge edge : current.getEdgesToPrint()) {
                        connectedNodes.add(edge.getDestination());
                    }
                    connectedNodes.removeAll(result);
                    unexplored.addAll(connectedNodes);
                }
            }
            result.add(sn);
            return result;
        }
    }

    @Override
    public Collection<DFANode> getDFANodes() {
        synchronized (this.ndfamap) {
            final List<DFANode> result = new ArrayList<>(this.ndfamap.values());
            result.add(sn.asDfaNode());
            return result;
        }
    }

    @Override
    public void addToStartnode(final NDFANode n) {
        checkNotNull(n, "Illegal to add null NDFANode");
        sn.add(n);
    }

    /**
     * Checks if the internal representation of the NodeStorage has cached an
     * DFA representation for the NDFA node n.
     * <p>
     * This method is not part of the NodeStorage interface, and is thus
     * intended to be used only for testing. If it is ever used for anything
     * else, then the NodeStorage interface should be expanded to include it.
     *
     * @param n an NDFA node that we wish to know if is cached or not.
     * @return true iff the NDFNode is connected from the startnode through an
     * epsilon edge.
     */
    public boolean isConnectedToStartnode(final NDFANode n) {
        checkNotNull(n, "Illegal to look for null NDFANode");
        return sn.getEpsilons().contains(n);
    }

    private final ConcurrentHashMap<Character, DFANode> nextFromDFAMap =
            new ConcurrentHashMap<>();

    // XXX This is really startnode specific and shouldn't necessarily
    //     be tightly coupled with the NodeStorage implementation.
    @Override
    public DFANode getNextFromStartNode(final Character ch) {
        checkNotNull(ch, "Illegal to use null char");
        return nextFromDFAMap.computeIfAbsent(ch, key -> {
            return sn.getNextDFA(ch, this);
        });
    }


    @Override
    public DFANode getDFANode(final SortedSet<NDFANode> ndfaset) {
        checkNotNull(ndfaset, "Illegal to use  null Set of NDFANodes");

        synchronized (ndfamap) {
            DFANode result = ndfamap.get(ndfaset);

            if (result == null) {
                result = new DFANodeImpl(ndfaset);
                ndfamap.put(ndfaset, result);

                updateFinalStatuses(result, ndfaset);
            }

            return result;
        }
    }

    /**
     * Traverse all the nodes in a collection of NDFANodes and update all the
     * regexps that are made final by this DFANode.
     *
     * @param dfaNode the set of DFA nodes to update.
     * @param ndfaset The set of NDFA nodes to update.
     */
    private void updateFinalStatuses(
            final DFANode dfaNode,
            final Collection<NDFANode> ndfaset) {

        checkNotNull(ndfaset);
        checkNotNull(dfaNode);

        for (final NDFANode node : ndfaset) {
            if (node.isTerminal()) {
                node.getRegexp().addTerminalNode(dfaNode);
            }
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package no.rmz.rmatch.impls;

import no.rmz.rmatch.interfaces.*;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

/**
 * Representation of a parsed regular expression.
 */
public final class RegexpImpl implements Regexp {


    /**
     * The Regexp string represented by this Regexp.
     */
    private final String rexpString;
    /**
     * The set of actions associated with this regular expression. These actions
     * will be invoked when a match for the regular expression is detected.
     */
    private final Set<Action> actions = new HashSet<>();
    /**
     * The set of nodes that are currently involved in matching expressions for
     * this regular expression.
     */
    private final Set<Node> activeNodes = new HashSet<>();


    /**
     * The set of nodes that permit successful termination of matches for this
     * regular expression.
     */
    private final Set<Node> terminatingNodes = new HashSet<>();
    /**
     * A map from MatchSets to Domination heaps, so that we can get a domination
     * heap that is used to represent the matches within a single match set.
     * <p>
     * XXX It is a bit unclear if it is right to put this map in the Regexp
     * implementation. It may in fact be much saner to put it into the MatchSet,
     * however, the MatchSet doesn't use it itself.
     */
    private final ConcurrentHashMap<MatchSet, DominationHeap> heaps;
    /**
     * The starting node in the NDFA that represents this regular expression.
     */
    private NDFANode myNode;

    /**
     * Make a new instance of Regexp representing a regular expression.
     *
     * @param rexpString a string representation of the regular expression.
     */
    public RegexpImpl(final String rexpString) {
        this.heaps = new ConcurrentHashMap<>();

        checkNotNull(rexpString, "regexpString can't be null");
        this.rexpString = rexpString;
    }

    @Override
    public boolean isCompiled() {
        return (myNode != null);
    }

    @Override
    public void setMyNDFANode(final NDFANode myNode) {
        assert (!isCompiled());
        this.myNode = myNode;
    }

    @Override
    public NDFANode getMyNode() {
        return myNode;
    }

    @Override
    public boolean isActiveFor(final Node n) {
        checkNotNull(n);
        return activeNodes.contains(n);
    }

    @Override
    public void addActive(final Node n) {
        checkNotNull(n);
        activeNodes.add(n);
    }

    @Override
    public void addTerminalNode(final Node n) {
        checkNotNull(n);
        terminatingNodes.add(n);
    }

    @Override
    public boolean hasTerminalNdfaNode(final Node n) {
        checkNotNull(n);
        return terminatingNodes.contains(n);
    }

    @Override
    public String getRexpString() {
        return rexpString;
    }

    @Override
    public void add(final Action a) {
        checkNotNull(a);
        actions.add(a);
    }

    @Override
    public void remove(final Action a) {
        checkNotNull(a);
        actions.remove(a);
    }

    @Override
    public boolean hasAction(final Action a) {
        checkNotNull(a);
        return actions.contains(a);
    }

    @Override
    public boolean hasActions() {
        return !actions.isEmpty();
    }

    @Override
    public void performActions(
            final Buffer b,
            final int start,
            final int end) {
        for (final Action a : actions) {
            a.performMatch(b, start, end);
        }
    }


    @Override
    public DominationHeap getDominationHeapCreateIfNotPresent(final MatchSet ms) {
        return heaps.computeIfAbsent(ms, k -> new DominationHeap());
    }

    @Override
    public void abandonMatchSet(final MatchSet ms) {
        heaps.remove(ms);
    }

    @Override
    public void registerMatch(final Match m) {
        assert (m != null);
        getDominationHeapCreateIfNotPresent(m.getMatchSet()).addMatch(m);
        assert hasMatch(m);
    }


    /**
     * True iff m can never become dominating.
     * @param  m the node that may or may not dominate this strongy.
     * @return true iff this node is strongly dominated by m
     */
    @Override
    public boolean isStronglyDominated(final Match m) {
        return false; // XXX Possible future optimization
    }

    //  XXX Is "this" dominating argument?
    @Override
    public boolean isDominating(final Match m) {
        if (m.getRegexp() != this) {
            return false;  // Can only dominate if regexp is the same
        }
        final DominationHeap dm = getDominationHeapCreateIfNotPresent(m.getMatchSet());
        if (dm.isEmpty()) {
            // If we don't know anyting about the ms of the m, we can't dominate
            return false;
        }
        final Match mostDominant = dm.getFirstMatch();
        if (m == mostDominant) {
            // The most dominant object  dominates itself? Weird but correct?
            return true;
        }
        return (Match.COMPARE_BY_DOMINATION.compare(mostDominant, m) > 0);
    }

    @Override
    public void abandonMatch(final Match m, final Character currentChar) {
        // TODO: All of those checks do take a significant amount of time.
        checkNotNull(m);
        checkArgument(this == m.getRegexp());
        checkArgument(hasMatches());
        checkArgument(hasMatch(m));

        final MatchSet ms = m.getMatchSet();

        final DominationHeap dh = heaps.get(ms);
        if (dh == null) {
            return;
        }

        dh.remove(m);
        if (dh.isEmpty()) {
            heaps.remove(ms);
        }
    }

    @Override
    public void commitUndominated(final RunnableMatchesHolder runnableMatches) {
        if (heaps.isEmpty()) {
            return;
        }

        // From each DominationHeap, only pick the most dominant (hence
        // un-dominated) element.
        for (final DominationHeap dh : heaps.values()) {
            // Commit the current match if it's final
            final Match firstMatch = dh.getFirstMatch();
            if (firstMatch.isFinal()) {
                runnableMatches.add(firstMatch);
            }
        }
        // Then clear the heaps
        heaps.clear();
    }

    @Override
    public String toString() {
        return "RegexpImpl{string = '"
                + rexpString
                + "', actions = "
                + actions + "}";
    }

    @Override
    public int compareTo(final Regexp other) {
        checkNotNull(other);
        return this.getRexpString().compareTo(other.getRexpString());
    }

    @Override
    public boolean equals(final Object o) {
        if (o instanceof RegexpImpl) {
            return compareTo((Regexp) o) == 0;
        } else {
            return false;
        }
    }


    @Override
    public int hashCode() {
        return this.rexpString.hashCode();
    }

    @Override
    public boolean hasMatch(final Match m) {
        checkNotNull(m);
        final MatchSet ms = m.getMatchSet();
        return (this.heaps != null) && this.heaps.containsKey(ms);
    }

    @Override
    public boolean hasMatches() {
        return (heaps != null) && (!heaps.isEmpty());
    }

}
package no.rmz.rmatch.impls;

import no.rmz.rmatch.interfaces.Buffer;
import no.rmz.rmatch.interfaces.LookaheadBuffer;

public class LookaheadBufferImpl implements LookaheadBuffer {

    private final Object lock = new Object();
    private final Buffer buffer;
    private Character peekedChar;
    private boolean havePeeked;

    public LookaheadBufferImpl(final Buffer buffer) {
        this.buffer = buffer;
        this.havePeeked = false;
        this.peekedChar = null;
    }

    @Override
    @Deprecated
    public String getCurrentRestString() {
        synchronized (lock) {
            return buffer.getCurrentRestString();
        }
    }

    @Override
    public String getString(int start, int stop) {
        synchronized (lock) {
            return buffer.getString(start, stop);
        }
    }

    @Override
    public boolean hasNext() {
        synchronized (lock) {
            return buffer.hasNext();
        }
    }

    @Override
    public Character getNext() {
        synchronized(lock) {
            if (havePeeked) {
                havePeeked = false;
                return peekedChar;
            } else {
                return buffer.getNext();
            }
        }
    }

    @Override
    public int getCurrentPos() {
        synchronized (lock) {
            return buffer.getCurrentPos();
        }
    }

    @SuppressFBWarnings("CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE") // TODO: Remove!!
    @SuppressWarnings("MethodDoesntCallSuperMethod")
    @Override
    public Buffer clone() {
        synchronized (lock) {
            return new LookaheadBufferImpl(buffer.clone());
        }
    }

    @Override
    public Character peek() {
        synchronized (lock) {
            if (!this.havePeeked) {
                this.havePeeked = true;
                if (buffer.hasNext()) {
                    this.peekedChar = buffer.getNext();
                } else {
                    this.peekedChar = null;
                }
            }
            return peekedChar;
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.impls;

import no.rmz.rmatch.compiler.RegexpParserException;
import no.rmz.rmatch.interfaces.*;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

/**
 * A multithreaded matcher. It will keep an array of matchers, into which it
 * will partition the regular expressions. Addition/Removal goes to one of the
 * matchers, not all of them. When running matches, all of the matchers are run
 * concurrently, and the MultiMatcher's implementation of the match method will
 * not complete until all of the matcher's match methods has completed.
 */
public final class MultiMatcher implements Matcher {

    /**
     * A simple guard against absolutely useless values of matchers. Now, 10K is
     * probably way too high for present day architectures, but one has
     * ambitions.
     */
    private static final int MAX_NO_OF_MATCHERS = 10000;
    /**
     * Look up the CPU/Cores/Memory configuration of the computer on which we
     * are running, and then use some heuristic to figure out an optimal number
     * of partitions to use.
     *
     * @return the number of partitions to use
     */
    private static int divineOptimalNumberOfMatchers() {
        final int cores = Runtime.getRuntime().availableProcessors();
        return cores;
    }

    /**
     * An array of matchers that are used when matching.
     */
    private final Matcher[] matchers;
    /**
     * The number of matchers in the matchers array.
     */
    private final int noOfMatchers;
    /**
     * The compiler used by all the matchers.
     */
    private final NDFACompiler compiler;
    /**
     * The regular expression factory used by all the matchers.
     */
    private final RegexpFactory regexpFactory;
    /**
     * An executor service that is used when invoking the sub-matchers.
     */
    private final ExecutorService executorService;

    /**
     * Create a new instance of the MultiMatcher.
     *
     * @param compiler The compiler used by all the matchers.
     * @param regexpFactory The regular expression factory used by all the
     * matchers.
     */
    public MultiMatcher(
            final NDFACompiler compiler,
            final RegexpFactory regexpFactory) {
        this(divineOptimalNumberOfMatchers(), compiler, regexpFactory);
    }

    /**
     * Create a new instance of the MultiMatcher.
     *
     * @param noOfMatchers The number of matchers in the matchers array.
     * @param compiler The compiler used by all the matchers.
     * @param regexpFactory The regular expression factory used by all the
     * matchers.
     */
    public  MultiMatcher(
            final int noOfMatchers,
            final NDFACompiler compiler,
            final RegexpFactory regexpFactory) {


        this.compiler = checkNotNull(compiler);
        this.regexpFactory = checkNotNull(regexpFactory);
        checkArgument(noOfMatchers >= 1, "No of partitions must be positive");
        checkArgument(noOfMatchers < MAX_NO_OF_MATCHERS,
                "No of partitions must be less than 100K");
        this.noOfMatchers = noOfMatchers;

        executorService = Executors.newFixedThreadPool(noOfMatchers);

        /**
         * Set up a set of partition into which we can pour regexps.
         */
        matchers = IntStream.range(0, noOfMatchers)
                .mapToObj(i -> new MatcherImpl(compiler, regexpFactory))
                .toArray(Matcher[]::new);
    }

    /**
     * Given a regular expression string, figure out which matcher to use.
     * Currently that calculation is based on the hash value of the string, but
     * in the future that may change.
     *
     * @param regexpString A string.
     * @return An integer in the range [0, noOfMatchers]
     */
    private Matcher getMatcher(final String regexpString) {
        checkNotNull(regexpString);
        final long hash = regexpString.hashCode()
                + (long) Integer.MAX_VALUE + 1;
        final int index = (int) (hash % noOfMatchers);

        return matchers[index];
    }

    @Override
    public void add(final String r, final Action a)
            throws RegexpParserException {
        getMatcher(r).add(r, a);
    }

    @Override
    public void remove(final String r, final Action a) {
        getMatcher(r).remove(r, a);
    }

    @Override
    public void match(final Buffer b) {
        assert (matchers.length == noOfMatchers);

        final CountDownLatch counter =
                new CountDownLatch(matchers.length);
        for (final Matcher matcher : matchers) {

            final Runnable runnable = () -> {
                matcher.match(b.clone());
                counter.countDown();
            };

            executorService.execute(runnable);
        }
        try {
            counter.await();
        } catch (InterruptedException ex) {
            throw new RuntimeException(ex);
        }
    }

    @Override
    public void shutdown() throws InterruptedException {
        for (final Matcher matcher : matchers) {
            matcher.shutdown();
        }
        executorService.shutdown();
        //noinspection ResultOfMethodCallIgnored
        executorService.awaitTermination(3, TimeUnit.SECONDS);
    }

    @Override
    public NodeStorage getNodeStorage() {
        // XXX This is wrong, since it only returns a subset of the
        //     nodes the multimatcher is using, but it's better than
        //     nothing if the objective is just to get a big graph to
        //     show someone.
        return matchers[0].getNodeStorage();
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.impls;

import no.rmz.rmatch.interfaces.Match;

import java.util.Comparator;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.logging.Logger;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

public final class DominationHeap {

    private static final Logger LOG = Logger.getLogger(DominationHeap.class.getName());

    private final PriorityBlockingQueue<Match> heap;

    public DominationHeap() {
        this(Match.COMPARE_BY_DOMINATION);
    }

    public DominationHeap(final Comparator<Match> comparator) {
        heap = new PriorityBlockingQueue<>(11, comparator);
    }

    public void addMatch(final Match m) {
        checkNotNull(m);
        heap.add(m);
    }

    public void remove(final Match m) {
        checkNotNull(m);
        checkState(!isEmpty());
        //noinspection ResultOfMethodCallIgnored
        heap.remove(m);
    }

    public boolean isEmpty() {
        return heap.isEmpty();
    }

    public Match getFirstMatch() {
        return heap.peek();
    }

    public boolean containsMatch(final Match m) {
        return heap.contains(m);
    }

    public int size() {
        return heap.size();
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package no.rmz.rmatch.impls;

import no.rmz.rmatch.interfaces.*;
import no.rmz.rmatch.utils.Counter;
import no.rmz.rmatch.utils.Counters;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

/**
 * A an implementation of the MatchSet interface. A MatchSet keeps a set of
 * matches which starts from the same location in the input. The MatchSet will
 * initially contain several matches. As the matching process progresses fewer
 * and fewer matches will remain, and eventually they will all be removed either
 * when firing an action, or just removed since it is discovered that the match
 * can not be brought to be final and then executed.
 */
public final class MatchSetImpl implements MatchSet {
    /**
     * A counter for MatchSetImpls.
     */
    private static final Counter MY_COUNTER =
            Counters.newCounter("MatchSetImpl");

    /**
     * Commit this match relative to a bunch of other matches.
     * <p>
     * Now committing simply means adding this match to a collection of matches
     * given as parameters.
     * <p>
     * However, the current match is only added to the collection of runnable
     * matches if it's dominating the regular expression it's representing
     * <p>
     * If the current match is dominating its regular expression, then add it
     * to the set of runnable matches given as parameter.
     * <p>
     * This method is public only to facilitate testing. It's not part of any
     * interface and shouldn't be used directly anywhere.
     *
     * @param m the match to commit.
     * @param runnableMatches a collector of runnable matches
     */
    public static void commitMatch(
            final Match m,
            final RunnableMatchesHolder runnableMatches) {
        assert (!m.isActive());
        assert (m.isFinal());

        final boolean isDominating =
                m.getRegexp().isDominating(m);
        final boolean isStronglyDominating =
                m.getRegexp().isStronglyDominated(m);

        if (isDominating && !isStronglyDominating) {
            runnableMatches.add(m);
            m.getMatchSet().removeMatch(m);
        }
    }

    @Override
    public int hashCode(){
        return Long.hashCode(getId());
    }

    @Override
    public boolean  equals(final Object o){
        if (o instanceof MatchSet) {
            final MatchSet ms = (MatchSet) o;
            return ms.getId() == getId();
        } else {
            return false;
        }
    }

    /**
     * The set of matches being pursued through this MatchSetImpl.
     */
    private final Set<Match> matches;
    /**
     * The current deterministic node that is used when pushing the matches
     * further.
     */
    private DFANode currentNode;
    /**
     * The start position of all the matches associated with this MatchSetImpl.
     */
    private final int start;
    /**
     * An identifier uniquely identifying this MatchSetImpl among other
     * MatchSetImpl instances.
     */
    private final long id;

    /**
     * Create a new MatchSetImpl.
     *
     * @param startIndex The start position in the input.
     * @param newCurrentNode The deterministic start node to start with.
     */
    public MatchSetImpl(
            final int startIndex,
            final DFANode newCurrentNode) {
        this.matches = ConcurrentHashMap.newKeySet();
        checkNotNull(newCurrentNode, "newCurrentNode can't be null");
        checkArgument(startIndex >= 0, "Start index can't be negative");
        this.currentNode = newCurrentNode;
        start = startIndex;
        id = MY_COUNTER.inc();

        // XXX This lines represents the most egregious
        //     bug in the whole regexp package, since it
        //     incurs a cost in both runtime and used memory
        //     directly proportional to the number of
        //     expressions (m) the matcher matches for.  For a
        //     text that is l characters long, this  in turns
        //     adds a factor O(l*m) to the resource use of the
        //     algorithm.  Clearly not logarithmic in the number
        //     of expressions, and thus a showstopper.

        // Maybe introduce a function "canStartwith" for a regexp, and traverse
        // the regexps to find the ones that can start with the current char,
        // and only add those to the match set.
        // Also remember this for the next time, so that this calculation is
        // only carried once per character, for all the regexps?

        for (final Regexp r : this.currentNode.getRegexps()) {
            // TODO: We _must_ find some heuristic to optimize away most
            // invocations of the next line.
            matches.add(this.currentNode.newMatch(this, r));
        }
    }

    @Override
    public int getStart() {
        return start;
    }

    @Override
    public Set<Match> getMatches() {
        return Collections.unmodifiableSet(matches);
    }

    @Override
    public boolean hasMatches() {
        return !matches.isEmpty();
    }

    /**
     * Progress one, if any matches are inactivated they are removed from the
     * match set. If they have something to contribute they are committed to
     * runnableMatches too.
     *
     * @param ns A NodeStorage used to find new nodes.
     * @param currentChar The current character.
     * @param currentPos The current position.
     * @param runnableMatches a container for runnable matches. Matches will
     *        be put here if they can be run, possibly, pending domination
     *        stuff.
     */
    @Override
    public void progress(
            final NodeStorage ns,
            final Character currentChar,
            final int currentPos,
            final RunnableMatchesHolder runnableMatches) {

        checkNotNull(ns, "NodeStorage can't be null");
        checkNotNull(currentChar, "currentChar can't be null");
        checkArgument(currentPos >= 0, "currentPos must be non-negative");
        checkNotNull(runnableMatches, "runnableMatches can't be null");
        checkNotNull(currentNode,
                "currentNode can never be null when progressing");

        // If no matches are active, then there is nothing to do
        // so just return.
        if (!hasMatches()) {
            return;
        }

        // This nested if/for/if statement takes
        // care of all the circumstances

        currentNode = currentNode.getNext(currentChar, ns);

        if (currentNode == null) {
            terminateAssociatedMatches(currentChar, runnableMatches);
            return;
        }

        failMatchesThatCannotContinue(currentChar);

        progressMatches(currentChar, currentPos, runnableMatches);
    }

    private void terminateAssociatedMatches(Character currentChar, RunnableMatchesHolder runnableMatches) {
        // Found no nodes going out of the current node, so we have
        // to stop pursuing the matches we've already got.
        // This actually marks the MatchSetImpl instance for
        // destruction, but we won't do anything more about that fact
        // from within this loop.

        for (final Match m : matches) {
            m.setInactive();
            if (m.isFinal()) {
                commitMatch(m, runnableMatches);
                if (!m.isAbandoned()) {
                    m.abandon(currentChar);
                }
            }
            removeMatch(m);
        }
    }

    private void progressMatches(
            final Character currentChar,
            final int currentPos,
            final RunnableMatchesHolder runnableMatches) {
        // got a current  node, so we'll se what we can do to progress
        // the matches we've got.
        for (final Match m : matches) {

            // Get the regexp associated with the
            // match we're currently processing.
            final Regexp regexp = m.getRegexp();
            final boolean isActive = currentNode.isActiveFor(regexp);

            m.setActive(isActive);

            // If this node is active for the current regexp,
            // that means that we don't have to abandon
            if (isActive) {
                processActiveMatch(currentPos, m, regexp);
            } else {
                progressInactiveMatch(currentChar, runnableMatches, m);
            }
        }
    }

    /**
     *  This is an active match, and we have somewhere
     *  to progress to, so we're advancing the end position of
     *  the match by one.
     * @param currentPos The current position
     * @param m The match we are progressing
     * @param regexp The regexp associated with the match
     */
    private void processActiveMatch(
            final int currentPos,
            final Match m,
            final Regexp regexp) {

        m.setEnd(currentPos);

        final boolean isFinal = currentNode.isTerminalFor(regexp);
        // If we're also in a final position for this match, note that
        // fact so that we can trigger actions for this match.
        m.setFinal(isFinal);
    }

    /**
     * We can't continue this match, perhaps it's already
     * final, and in that case we should commit what we've got
     * before abandoning it.
     * @param currentChar The character we are currently processing
     * @param runnableMatches The matches we are currently running
     * @param m The current match
     */
    private void progressInactiveMatch(final Character currentChar, final RunnableMatchesHolder runnableMatches, final Match m) {

        if (m.isFinal()) {
            commitMatch(m, runnableMatches);
        }

        if (!m.isAbandoned()) {
            m.abandon(currentChar);
        }

        removeMatch(m);
    }

    private void failMatchesThatCannotContinue(Character currentChar) {
        // Check if there are any regexps for which matches must fail
        // for this node, and then fail them.
        if (currentNode.failsSomeRegexps()) {
            for (final Match m : matches) {
                if (currentNode.isFailingFor(m.getRegexp())) {
                    m.abandon(currentChar);
                    matches.remove(m);
                }
            }
        }
    }


    @Override
    public void removeMatch(final Match m) {
        checkNotNull(m);
        m.getRegexp().abandonMatchSet(this);
        matches.remove(m);
    }

    @Override
    public void finalCommit(final RunnableMatchesHolder runnableMatches) {
        checkNotNull(runnableMatches, "Target can't be null");

        final Set<Regexp> visitedRegexps = new HashSet<>();

        for (final Match m : matches) {
            if (m.notReadyForCommit()) {
                continue;
            }
            final Regexp r = m.getRegexp();
            if (!visitedRegexps.contains(r)) {
                visitedRegexps.add(r);
                r.commitUndominated(runnableMatches);
            }
            removeMatch(m);
        }
    }

    @Override
    public long getId() {
        return id;
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.impls;

import no.rmz.rmatch.compiler.NDFACompilerImpl;
import no.rmz.rmatch.compiler.RegexpParserException;
import no.rmz.rmatch.interfaces.*;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * An implementation of the Matcher interface that hooks together
 * various component that together makes up a real matcher.
 */
public final class MatcherImpl implements Matcher {

    /**
     * The compiler we will use.
     */
    private final NDFACompiler compiler;

    /**
     * The regexp storage we will use.
     */
    private final RegexpStorage rs;

    /**
     * Our precious MatchEngine.
     */
    private final MatchEngine me;

    /**
     * Our equally prescious NodeStorage. Our precioussss.
     */
    private final NodeStorage ns;

    /**
     * Create a new matcher using the default compiler and regexp
     * factory.  This is usually a good choice for production use.
     */
    public MatcherImpl() {
        this(new NDFACompilerImpl(), RegexpFactory.DEFAULT_REGEXP_FACTORY);
    }

    /**
     * This is useful for testing when we sometimes want to
     * inject mocked compilers and regexp factories.
     *
     * @param compiler A compiler to use.
     * @param regexpFactory A regexp factory to use.
     */
    public MatcherImpl(
            final NDFACompiler compiler,
            final RegexpFactory regexpFactory) {
        this.compiler = checkNotNull(compiler);
        checkNotNull(regexpFactory);
        ns = new NodeStorageImpl();
        rs = new RegexpStorageImpl(ns, compiler, regexpFactory);
        me = new MatchEngineImpl(ns);
    }

    @Override
    public void add(final String r, final Action a)
            throws RegexpParserException {
        synchronized (rs) {
            rs.add(r, a);
        }
    }

    @Override
    public void remove(final String r, final Action a) {
        synchronized (rs) {
            rs.remove(r, a);
        }
    }

    @Override
    public void match(final Buffer b) {
        synchronized (me) {
            me.match(b);
        }
    }

    @Override
    public NodeStorage getNodeStorage() {
        return ns;
    }

    @Override
    public void shutdown() throws InterruptedException {
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.impls;

import no.rmz.rmatch.compiler.RegexpParserException;
import no.rmz.rmatch.interfaces.*;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * An implementation of the regular expression storage interface. It stores all
 * of its regular expressions in memory.
 */
public final class RegexpStorageImpl implements RegexpStorage {

    /**
     * A map mapping string representations of regular expressions to Regexps
     * instances representing those strings.
     *
     */
    private final Map<String, Regexp> regexps = new HashMap<>();
    /**
     * A NodeStorage instance that is used when creating new nondeterminstic
     * nodes.
     */
    private final NodeStorage storage;
    /**
     * A compiler that is used when compiling strings into nondeterminstic
     * nodes.
     */
    private final NDFACompiler compiler;
    /**
     * A factory that will produce a Regexp instance for our strings.
     */
    private final RegexpFactory regexpFactory;

    /**
     * Create a new RegexpStorageImpl instance using the default regexp factory.
     * This is the creator that should be used in production settings.
     *
     * @param storage the NodeStorage.
     * @param compiler the compiler.
     */
    public RegexpStorageImpl(
            final NodeStorage storage,
            final NDFACompiler compiler) {
        this(storage, compiler, RegexpFactory.DEFAULT_REGEXP_FACTORY);
    }

    /**
     * This creator allows a particular RegexpFactory to be used. This creator
     * is only intended to be used to inject mocked RegexpFactories during
     * testing.
     *
     * @param storage the NodeStorage.
     * @param compiler the compiler.
     * @param regexpFactory A RegexpFactory instance to use.
     */
    public RegexpStorageImpl(
            final NodeStorage storage,
            final NDFACompiler compiler,
            final RegexpFactory regexpFactory) {
        this.storage = checkNotNull(storage, "Null storage is meaningless");
        this.compiler = checkNotNull(compiler, "Null compiler is meaningless");
        this.regexpFactory = checkNotNull(regexpFactory,
                "regexpFactory can't be null");
    }

    @Override
    public boolean hasRegexp(final String regexp) {
        synchronized (regexps) {
            return regexps.containsKey(regexp);
        }
    }

    @Override
    public Regexp getRegexp(final String regexpString) {
        synchronized (regexps) {
            Regexp r = regexps.get(regexpString);
            if (r == null) {
                r = regexpFactory.newRegexp(regexpString);
                regexps.put(regexpString, r);
            }
            return r;
        }
    }

    @Override
    public void add(final String regexpString, final Action action)
            throws RegexpParserException {
        synchronized (regexps) {
            final Regexp r = getRegexp(regexpString);
            r.add(action);

            if (!r.isCompiled()) {
                final NDFANode n = compiler.compile(r, this);
                assert (n != null);
                r.setMyNDFANode(n);
                storage.addToStartnode(n);
            }
        }
    }

    @Override
    public void remove(final String rexp, final Action a) {
        synchronized (regexps) {
            final Regexp r = getRegexp(rexp);

            r.remove(a);
            if (!r.hasActions()) {
                regexps.remove(rexp);
            }
        }
    }

    @Override
    public Set<String> getRegexpSet() {
        synchronized (regexps) {
            return regexps.keySet();
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


package no.rmz.rmatch.impls;

import no.rmz.rmatch.compiler.NDFACompilerImpl;
import no.rmz.rmatch.interfaces.Matcher;
import no.rmz.rmatch.interfaces.RegexpFactory;

import java.lang.management.ManagementFactory;
import java.lang.management.OperatingSystemMXBean;


/**
 * A factory instance that will generate matcher instances that
 * are optimized for the current execution environment.  It's
 * all heuristic, but it ment to represent the best guess, based
 * on the available empirical data as to what willl give the
 * best performance.
 */
public class MatcherFactory {

    /**
     * A management bean that we use to probe the execution environment.
     */
    private static final OperatingSystemMXBean OS_MBEAN
            = ManagementFactory.getOperatingSystemMXBean();

    /**
     * The number of processors available to us.
     */
    private static final int AVAILABLE_PROCESSORS
            = OS_MBEAN.getAvailableProcessors();

    /**
     * Return a matcher that is assumed to be optimal for the current execution
     * environment. This is the recommenced way to get a matcher to use.
     * @return a new Matcher instance.
     */
    public static Matcher newMatcher() {

        final int noOfPartitions;
        if (AVAILABLE_PROCESSORS > 2) {
            noOfPartitions = (int)(AVAILABLE_PROCESSORS * 1.5);
        } else {
            noOfPartitions = 1;
        }

        return new MultiMatcher(
                noOfPartitions,
                new NDFACompilerImpl(),
                RegexpFactory.DEFAULT_REGEXP_FACTORY);
    }

    private MatcherFactory() {
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.impls;

import no.rmz.rmatch.interfaces.Match;
import no.rmz.rmatch.interfaces.MatchSet;
import no.rmz.rmatch.interfaces.Regexp;
import no.rmz.rmatch.utils.Counter;
import no.rmz.rmatch.utils.Counters;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * A representation of a match implementing the Match interface.
 */
public final class MatchImpl implements Match {
    /**
     * A counter that is increased every time a new MatchImpl is generated. Used
     * for logging and benchmarking.
     */
    private static final Counter counter = Counters.newCounter("MatchImpl");

    /**
     * True iff the match is final, in the sense that its current state
     * represents a legal termination of the match.
     */
    private boolean isFinal;
    /**
     * True iff this match can expect to progress further.
     */
    private boolean isActive;
    /**
     * The end position of the match. The start position can be found indirectly
     * through the MatchSet ms.
     */
    private int end;
    /**
     * The Regexp for which this match is valued.
     */
    private final Regexp r;
    /**
     * The MatchSet of which this Match is a part..
     */
    private final MatchSet ms;
    /**
     * An unique ID for the set of matches.
     */
    private final long id;

    /**
     * Create a new Match implementation.
     *
     * @param ms The MatchSet with which this Match is associated.
     * @param r The Regexp with which this match is associated.
     * @param isFinal True iff the match is final from the get-go.
     */
    public MatchImpl(
            final MatchSet ms,
            final Regexp r,
            final boolean isFinal) {
        this.ms = checkNotNull(ms, "MatchSet can't be null");
        this.r = checkNotNull(r, "Regexp can't be null");
        this.isFinal = isFinal; // why?
        end = ms.getStart(); // XXX Bogus
        isActive = true;
        r.registerMatch(this);
        id = counter.inc();
    }

    /**
     * Implement hashing based on the unique ID.
     */
    @Override
    public int hashCode() {
        return (int) (this.id ^ (this.id >>> 32));
    }

    /**
     * Create a new Match implementation. Assumes that the match is not
     * initially final.
     *
     * @param ms The MatchSet with which this Match is associated.
     * @param r The Regexp with which this match is associated.
     */
    public MatchImpl(final MatchSet ms, final Regexp r) {
        this(ms, r, false); //  By default matches are not final
    }

    @Override
    public String toString() {
        return "[Match  regexpString = '"
                + r.getRexpString() + "' start = "
                + ms.getStart() + " end = "
                + end + " isFinal = "
                + isFinal + " isActive " + isActive + "]";
    }

    @Override
    public long getId() {
        return id;
    }

    @Override
    public void abandon(final Character currentChar) {
        // TODO: Make optional, only run when debugging. checkState(!isAbandoned());
        this.r.abandonMatch(this, currentChar);
        this.isActive = false;
    }

    @Override
    public boolean isAbandoned() {
        return !(isActive || r.hasMatch(this));
    }

    @Override
    public MatchSet getMatchSet() {
        return ms;
    }

    @Override
    public void setIsFinal() {
        isFinal = true;
    }

    @Override
    public int getStart() {
        return ms.getStart();
    }

    @Override
    public int getEnd() {
        return end;
    }

    @Override
    public void setEnd(final int end) {
        this.end = end;
    }

    @Override
    public Regexp getRegexp() {
        return r;
    }

    @Override
    public boolean isActive() {
        return isActive;
    }

    @Override
    public boolean isFinal() {
        return isFinal;
    }

    @Override
    public void setNotFinal() {
        isFinal = false;
    }

    @Override
    public void setInactive() {
        isActive = false;
    }

    @Override
    public void setActive(final boolean active) {
        this.isActive = active;
    }

    @Override
    public void setFinal(final boolean aFinal) {
        this.isFinal = aFinal;
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package no.rmz.rmatch.impls;

// XXX Don't mix: Either use some sort of NDFA with
//     a charmap (and
//     epsilons), or use something else. Don't mix!!!

import no.rmz.rmatch.abstracts.AbstractNDFANode;
import no.rmz.rmatch.interfaces.*;

import java.util.*;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * A startnode is a special kind of node that a Node Storage has only one of. It
 * is used to initiate new matches, so all the NDFAs for all the regular
 * expression associated with that NodeStorage instance has an epsilon edge
 * going out of the StartNode into it.
 * <p>
 * A StartNode only has epsilon edges going in and out of it, but apart from
 * that it's nothing special.
 */
public final class StartNode extends AbstractNDFANode {
    /**
     * The regexp that is nominally associated with the start node. It is an
     * empty expression that does not match anything.
     */
    private static final Regexp START_NO_REGEXP = new RegexpImpl(""); // XX??

    /**
     * The DFA that represents the StartNode instance.
     */
    private DFANodeImpl topDFA = new DFANodeImpl(Collections.EMPTY_SET);
    /**
     * A monitor that is used to synchronize access to the StartNode instance.
     */
    private final Object topDfaMonitor = new Object();
    /**
     * Map of directly outgoing NDFANodes. XXX Never added to. Review and most
     * likely delete.
     */
    private final Map<Character, NDFANode> ndfaOutMap;

    /**
     * Create a enw StartNode instance.
     *
     * @param  ns the node storage this StartNode is associated with.
     */
    public StartNode(final NodeStorage ns) {
        super(START_NO_REGEXP, false);
        this.ndfaOutMap = new HashMap<>();
    }

    // XXX Since we already have the NodeStorage, why do we need
    //     a parameter for it? This is almost certainly a bug. Fix.

    /**
     * Get the next DFA for a specific character.
     *
     * @param ch The charater
     * @param ns The NodeStorage to use.
     * @return a new DFA node.
     */
    public DFANode getNextDFA(final Character ch, final NodeStorage ns) {

        if (this.topDFA.hasLinkFor(ch)) {
            return this.topDFA.getNext(ch, ns);
        }

        final SortedSet<NDFANode> nextSet = getNextSet(ch);

        final DFANode result;
        if (!nextSet.isEmpty()) {
            result = ns.getDFANode(nextSet);
            this.topDFA.addLink(ch, result);
        } else {
            result = null;
        }

        return result;
    }

    /**
     * Add a new NDFA Node to the startnode.
     *
     * @param n The node to add through an epsilon edge.
     */
    public void add(final NDFANode n) {
        checkNotNull(n, "Can't add null NDFA node");
        addEpsilonEdge(n);
    }

    @Override
    public NDFANode getNextNDFA(final Character ch) {
        return ndfaOutMap.get(ch);
    }

    @Override
    public Collection<PrintableEdge> getEdgesToPrint() {
        return getEpsilonEdgesToPrint();
    }

    public DFANodeImpl asDfaNode() {
        return this.topDFA;
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package no.rmz.rmatch.impls;

import no.rmz.rmatch.interfaces.*;
import no.rmz.rmatch.utils.Counter;
import no.rmz.rmatch.utils.Counters;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * An implementation of deterministic finite automata nodes DFA.
 */
public final class DFANodeImpl implements DFANode {

    /**
     * Counter used to figure out both how many DFA nodes are allocated, and to
     * generate unique IDs for the nodes (put in the "id" variable).
     */
    private static final Counter COUNTER = Counters.newCounter("DFANodeImpl");
    /**
     * A counter for known edges going to other DFAs.
     */
    private static final Counter KNOWN_DFA_EDGES_COUNTER =
            Counters.newCounter("Known DFA Edges");

    /**
     * The set of regular expression this node represents.
     */
    private final Set<Regexp> regexps = new HashSet<>();
    /**
     * A map of computed edges going out of this node. There may be more edges
     * going out of this node, but these are the nodes that has been encountered
     * so far during matching.
     */
    private final ConcurrentMap<Character, DFANode> nextMap = new ConcurrentHashMap<>();

    /**
     * The set of NDFANodes that this DFA node is representing.  It is immutable!
     * TODO: Make this into an immutable set.
     */
    private final SortedSet<NDFANode> basis = new TreeSet<>();

    /**
     * The set of regular expressions for which this node will make a match
     * fail.
     */
    private final Set<Regexp> isFailingSet = ConcurrentHashMap.newKeySet();

    /**
     * An unique (per VM) id for this DFANode.
     */
    private final long id;
    /**
     * A cache used to memoize check for finality for particular regexps.
     */
    private final Map<Regexp, Boolean> baseIsFinalCache = new ConcurrentHashMap<>();
    private final List<NDFANode> basisList;

    /**
     * Create a new DFA based representing a set of NDFA nodes.
     *
     * @param ndfanodeset the set of NDFA nodes the new DFA node should
     * represent.
     */
    @SuppressWarnings("SpellCheckingInspection")
    public DFANodeImpl(final Set<NDFANode> ndfanodeset) {
        basis.addAll(ndfanodeset);
        initialize(basis);
        this.basisList = new ArrayList<>(this.basis);
        id = COUNTER.inc();
    }

    /**
     * Initialize the new node based on a set of NDFA nodes. Notify the regexp
     * about this DFA node being active for that expr.
     *
     * @param ndfanodeset the set of NDFA nodes this DFA node is based on.
     */
    private void initialize(final Set<NDFANode> ndfanodeset) {
        for (final NDFANode node : ndfanodeset) {
            checkNotNull(node, "no null nodes allowed!");
            final Regexp r = checkNotNull(node.getRegexp(),
                    "Current regexp can't be null");
            addRegexp(r);
            r.addActive(this);
            if (node.isTerminal()) {
                r.addTerminalNode(this);
            }

            if (node.isFailing()) {
                isFailingSet.add(r);
            }
        }
    }

    /**
     * Return an unique (within this VM) id for this DFANode.
     *
     * @return the id
     */
    @Override
    public long getId() {
        return id;
    }

    /**
     * Get the nextmap. This is a "backdoor" into the implementation, and should
     * only be used by those who know what they are doing. It is emphatically
     * not intended to be used during matching. Currently it is only used to
     * print graphs, and that is done when the matcher isn't running. Be
     * careful!
     *
     * @return the map of nodes going out of this DFA node.
     */
    public Map<Character, DFANode> getNextMap() {
        return Collections.unmodifiableMap(nextMap);
    }

    @Override
    public boolean isActiveFor(final Regexp r) {
        return r.isActiveFor(this);
    }

    @Override
    public boolean isTerminalFor(final Regexp r) {
        return r.hasTerminalNdfaNode(this);
    }

    @Override
    public Match newMatch(final MatchSet ms, final Regexp r) {
        return new MatchImpl(ms, r, baseIsFinalFor(r));
    }

    @Override
    public void addRegexp(final Regexp r) {
        regexps.add(r);
    }

    @Override
    public Set<Regexp> getRegexps() {
        return Collections.unmodifiableSet(regexps);
    }

    @Override
    public void addLink(final Character c, final DFANode n) {
        nextMap.put(c, n);
    }

    @Override
    public boolean hasLinkFor(final Character c) {
        return nextMap.containsKey(c);
    }

    /**
     * Get the next basis for a DFANode by pursuing the current basis through
     * the character.
     *
     * @param ch the character to explore.
     * @return A set of NDFANodes that serves as basis for the next DFANode.
     */
    private SortedSet<NDFANode> getNextThroughBasis(final Character ch) {
        final TreeSet<NDFANode> result = new TreeSet<>();

        for (final NDFANode n : basis) {
            result.addAll(n.getNextSet(ch));
        }

        return result;
    }

    @Override
    public DFANode getNext(final Character ch, final NodeStorage ns) {
        return nextMap.computeIfAbsent(ch, key -> {
            KNOWN_DFA_EDGES_COUNTER.inc();

            final SortedSet<NDFANode> nodes = getNextThroughBasis(ch);
            if (!nodes.isEmpty()) {
                return ns.getDFANode(nodes);
            }
            return null;
        });
    }

    @Override
    public void removeLink(final Character c) {
        nextMap.remove(c);
    }


    /**
     * Calculate if the present DFANode is final for a particular regular
     * expression.
     *
     * @param r a regexp
     * @return true iff this node is final for r.
     */
    private boolean baseIsFinalFor(final Regexp r) {
        return baseIsFinalCache.computeIfAbsent(r,
                key -> basisList.parallelStream().anyMatch(key::hasTerminalNdfaNode));
    }

    @Override
    public boolean failsSomeRegexps() {
        return !isFailingSet.isEmpty();
    }

    @Override
    public boolean isFailingFor(final Regexp regexp) {
        return isFailingSet.contains(regexp);
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.impls;

import no.rmz.rmatch.interfaces.*;

import java.util.*;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

/**
 * An implementation of a MatchEngine that can be used to match regular
 * expressions against input.
 */
public final class MatchEngineImpl implements MatchEngine {
    /**
     * Perform matches by triggering the relevant actions.
     *
     * @param b The buffer we are reading matches from.
     * @param matches The collection of matching we are performing.
     * @param bePermissive  If permissive, set all the matches to be
     *                      inactive and abandoned, otherwise
     *                      expect them to be inactive and abandoned
     *                      prior to invocation.
     */
    private static void performMatches(
            final Buffer b,
            final Collection<Match> matches,
            final Boolean bePermissive) {
        checkNotNull(matches);
        checkNotNull(b);
        for (final Match match : matches) {
            if (bePermissive) {
                match.setInactive();
            }
            performMatch(b, match);
            if (bePermissive) {
                match.abandon(null);
            }
        }
    }
    /**
     * Perform actions associated with a match.
     * @param b A buffer where the matched content is located.
     * @param m The match to be performed.
     */
    private static void performMatch(final Buffer b, final Match m) {
        checkNotNull(m);
        checkNotNull(b);
        if (m.isFinal()) {
            final int start = m.getStart();
            final int end = m.getEnd();
            final Regexp regexp = m.getRegexp();
            
            regexp.performActions(b, start, end);
        }
    }

    /**
     * The instance that is used to map sets of NDFA nodes to NDFA nodes, and if
     * necessarily create new DFA nodes.
     */
    private final NodeStorage ns;

    /**
     * Implements the MatchEngine interface, uses a particular NodeStorage
     * instance.
     *
     * @param ns non null NodeStorage instance.
     */
    public MatchEngineImpl(final NodeStorage ns) {
        this.ns = checkNotNull(ns, "NodeStorage can't be null");

    }

    /**
     * Progress the matcher one step.
     *
     * @param b The buffer we are reading characters from.
     * @param currentChar The current character.
     * @param currentPos The current position.
     * @param activeMatchSets The set of active match sets.
     */
    private void matcherProgress(
            final Buffer b,
            final Character currentChar,
            final int currentPos,
            final Set<MatchSet> activeMatchSets) {

        checkNotNull(currentChar, "currentChar can't be null");
        checkArgument(currentPos >= 0, "Pos in buf must be non-negative");

        // Progress all the already active matches and collect
        // the runnables.  The runnables may or may not be
        // active when they run, but they must be final.
        final RunnableMatchesHolder runnableMatches =
                new RunnableMatchesHolderImpl();

        if (!activeMatchSets.isEmpty()) {
            final Set<MatchSet> setsToRemove = new HashSet<>();
            for (final MatchSet ms : activeMatchSets) {
                ms.progress(ns, currentChar, currentPos, runnableMatches);
                if (!ms.hasMatches()) {
                    setsToRemove.add(ms);
                }
            }
            activeMatchSets.removeAll(setsToRemove);
        }

        // If the current input character opened up a possibility of new
        // matches, then by all means make a new match set to represent
        // that fact.
        final DFANode startOfNewMatches = ns.getNextFromStartNode(currentChar);
        if (startOfNewMatches != null) {
            final MatchSet ms;
            ms = new MatchSetImpl(currentPos, startOfNewMatches);
            if (ms.hasMatches()) {
                activeMatchSets.add(ms);
            }
        }

        // Then run through all the active match sets to see
        // if there are any
        // matches that should be commited.  When a matchSet is fresh out
        // of active matches it should be snuffed.

        for (final MatchSet ms : activeMatchSets) {

            // Collect runnable matches into the runnableMatches
            // instance.
            ms.finalCommit(runnableMatches);

            // If there are no matches in this match set, then we shouldn't
            // consider it any further.
            if (!ms.hasMatches()) {
                activeMatchSets.remove(ms);
            }
        }

        // Run through all the runnable matches and perform actions.
        // (Don't be permissive by default, hence "false").
        performMatches(b, runnableMatches.getMatches(), false);
    }

    @Override
    public void match(final Buffer b) {
        checkNotNull(b, "Buffer can't be null");

        final Set<MatchSet> activeMatchSets;
        activeMatchSets = Collections.synchronizedSet(
                new TreeSet<>(MatchSet.COMPARE_BY_ID));

        // Advance all match sets forward one character.
        while (b.hasNext()) {
            final Character nextChar = b.getNext();
            final int currentPos = b.getCurrentPos();
            matcherProgress(b, nextChar, currentPos, activeMatchSets);
        }

        // Handle the stragglers
        for (final MatchSet ms : activeMatchSets) {
            // Be permissive when handling stragglers
            performMatches(b, ms.getMatches(), true);
        }

        activeMatchSets.clear();
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.impls;

import static com.google.common.base.Preconditions.checkArgument;
import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import no.rmz.rmatch.interfaces.Match;
import no.rmz.rmatch.interfaces.RunnableMatchesHolder;

/**
 * A holder for runnable matches.
 */
public final class RunnableMatchesHolderImpl implements RunnableMatchesHolder {

    private final Set<Match> matches;

    public RunnableMatchesHolderImpl() {
        this.matches = Collections.newSetFromMap(new ConcurrentHashMap<>());
    }

    /**
     * Add a match to the set. Fail if the match isn't final.
     *
     * @param m the match to add.
     */
    @Override
    public void add(final Match m) {
        checkArgument(m.isFinal());
        matches.add(m);
    }

    /**
     * Get the set of matches.
     *
     * @return the set of matches.
     */
    @Override
    public Set<Match> getMatches() {
        return Collections.unmodifiableSet(matches);
    }

    /**
     * True iff we hold any matches.
     *
     * @return true iff we hold any matches.
     */
    boolean hasMatches() {
        return !matches.isEmpty();
    }

    @Override
    public String toString() {
        return "RunnableMatchesHolder[" + matches + "]";
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.utils;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * A mixture between a set and a LIFO stack. Adding the same element more than
 * once will not insert it more than once.
 * @param <T> is the class of the instances that the LifoSet will contain.
 */
public final class LifoSet<T> {

    /**
     * A set that holds all the member of the lifoset.
     */
    private final Set<T> members = new HashSet<>();
    /**
     * A list that is used to represent the LIFO aspect of the LIFO set.
     */
    private final List<T> lifo = new ArrayList<>();

    /**
     * True iff there are no members.
     *
     * @return true iff no content in members.
     */
    public boolean isEmpty() {
        synchronized (members) {
            return members.isEmpty();
        }
    }

    /**
     * If the element being added was already present in the LIFOset, then it
     * isn't added again, otherwise it is added.
     *
     * @param t the element to be added
     * @return true iff the element was not already present and therefore was
     * added by the add method, otherwise (obviously) false.
     */
    public boolean add(final T t) {
        synchronized (members) {
            if (!members.contains(t)) {
                members.add(t);
                lifo.add(t);
                return true;
            } else {
                return false;
            }
        }
    }

    /**
     * Return the last element that was added to the LIFOset, then remove it
     * from the LIFOset.
     *
     * @return the element that was last added to the LIFOset.
     */
    public T pop() {
        synchronized (members) {
            if (isEmpty()) {
                throw new IllegalStateException(
                        "Attempt to remove something from an empty LifoSet");
            }
            final T result = lifo.remove(0);
            members.remove(result);
            return result;
        }
    }

    /**
     * Add a set of elements to the LifoSet. The order in which they are added
     * is the same as they would be returned in by the default iterator for the
     * set.
     *
     * @param elementSet a set of elements to add.
     */
    public void addAll(final Set<T> elementSet) {
        synchronized (members) {
            for (final T t : elementSet) {
                add(t);
            }
        }
    }

    /**
     * Return true iff the LifoSet contains the element.
     *
     * @param element the element to check for the presence of.
     * @return true iff the parameter is present in the LifoSet.
     */
    public boolean contains(final T element) {
        synchronized (members) {
            return members.contains(element);
        }
    }

    @Override
    public String toString() {
        synchronized (members) {
            return "LifoSet{" + "lifo=" + lifo + '}';
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.utils;

import no.rmz.rmatch.interfaces.Buffer;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * An implementation of the Buffer interface, that holds all of the input as a
 * String.
 */
public final class StringBuffer implements Buffer, Cloneable {

    /**
     * A string containing the entire content of the buffer.
     */
    private final String str;
    /**
     * The current position of the buffer.
     */
    private int currentPos;
    /**
     * The current character.
     */
    private char currentChar;
    /**
     * A montor instance used when synchronizing access to this instance.
     */
    private final Object monitor = new Object();

    /**
     * Create a new instance, with content as a string.
     *
     * @param str The string we will return character by character.
     */
    public StringBuffer(final String str) {
        this.str = checkNotNull(str);
        currentPos = -1;
    }

    /**
     * Clone the other string buffer.
     * @param aThis the buffer to clone.
     */
    private StringBuffer(final StringBuffer aThis) {
        this.str = aThis.str;
        this.currentPos = aThis.currentPos;
        this.currentChar = aThis.currentChar;
    }

    /**
     * Set the current position to be somewhere in the string.
     *
     * @param pos the pos to set currentPos to.
     */
    public void setCurrentPos(final int pos) {
        synchronized (monitor) {
            assert pos > 0 && pos < str.length();
            currentPos = pos;
        }
    }

    @Override
    public boolean hasNext() {
        synchronized (monitor) {
            int lastPos = getLength() - 2;
            return currentPos <= lastPos;
        }
    }

    /**
     * Advance the position pointer by one, and update the currentChar value.
     */
    private void progress() {
        synchronized (monitor) {
            currentPos += 1;
            currentChar = str.charAt(currentPos);
        }
    }

    @Override
    public Character getNext() {
        synchronized (monitor) {
            progress();
            return currentChar;
        }
    }

    @Override
    public int getCurrentPos() {
        synchronized (monitor) {
            return currentPos;
        }
    }

    /**
     * Get the length of the current string.
     *
     * @return the length of the string.
     */
    public int getLength() {
        synchronized (monitor) {
            return str.length();
        }
    }

    @Override
    public String getString(final int start, final int stop) {
        synchronized (monitor) {
            return str.substring(start, stop);
        }
    }

    /**
     * Get the string from the start position to the end.
     * @param start start position.
     * @return  the string from the start position to the end.
     */
    public String getCurrentRestString(final int start) {
        synchronized (monitor) {
            int end = getLength();
            return getString(start, end);
        }
    }

    @Override
    public String getCurrentRestString() {
        synchronized (monitor) {
            return getCurrentRestString(getCurrentPos() + 1);
        }
    }

    @Override
    public String toString() {
        synchronized (monitor) {
            return "[StringBuffer currentPos = " + currentPos
                    + ". str = " + str + "]";
        }
    }

    @SuppressWarnings("MethodDoesntCallSuperMethod")
    @Override
    public Buffer clone() {
        return new StringBuffer(this);
    }
}
package no.rmz.rmatch.utils;

import java.util.Collection;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

/**
 * Utility class to produce counters that are uniquely named (within the VM).
 */
public final class Counters {

    /**
     * We implement the singelton pattern, and this is the instance.
     */
    private static final Counters INSTANCE = new Counters();

    /**
     * Get a new counter, uniquely named.
     *
     * @param name the name of the counter to create.
     * @param canBeDecremented
     * @return THe newly crated counter.
     */
    public static Counter newCounter(final String name, final boolean canBeDecremented) {
        return INSTANCE.privateNewCounter(name, canBeDecremented);
    }

    public static Counter newCounter(final String name) {
        return INSTANCE.privateNewCounter(name, false);
    }

    /**
     * Get a collection of counters.
     *
     * @return All the known counters.
     */
    public static Collection<Counter> getCounters() {
        return INSTANCE.privateGetCounters();
    }

    /**
     * Dump the counters to stdout.
     */
    public static void dumpCounters() {
        INSTANCE.privatedumpCounters();
    }

    /**
     * A map mapping strings to countes.
     */
    private final Map<String, Counter> counters =
 new TreeMap<>();

    /**
     * Since this is an utility class we can't have public constructor.
     */
    private Counters() {
    }

    /**
     * Dump the counters to stdout.
     */
    public void privatedumpCounters() {
        for (final Entry<String, Counter> entry : counters.entrySet()) {
        }
    }

    /**
     * Generate a new counter and put it into the counters map. throws
     * IllegalStateException if the name is already registred.
     *
     * @param name The name fo the counter.
     * @return a counter.
     */
    private Counter privateNewCounter(final String name, boolean canBeDecremented) {
        synchronized (counters) {
            if (counters.containsKey(name)) {
                throw new IllegalStateException(
                        "Attempt to get two counters with name " + name);
            } else {
                final Counter result = new Counter(name, canBeDecremented);
                counters.put(name, result);
                return result;
            }
        }
    }


    private Counter privateNewCounter(String name) {
        return privateNewCounter(name, false);
    }


    /**
     * Get all of the counters.
     *
     * @return a collection of counters.
     */
    private Collection<Counter> privateGetCounters() {
        synchronized (counters) {
            return counters.values();
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.utils;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import java.util.Comparator;
import java.util.TreeMap;

/**
 * Simulating a heap using a TreeMap.
 * @param <T> The type of the elements in the simulated heap.
 */
public final class SimulatedHeap<T> {

    /**
     * We use a TreeMap to represent the heap.
     */
    private final TreeMap<T, T> tm;

   /**
    * Create a new simulated heap using the comparator c.
    * @param c a comparator of T elements.
    */
    public SimulatedHeap(final Comparator<T> c) {
        checkNotNull(c);
        tm = new TreeMap<>(c);
    }

    /**
     * Add an element to the heap.
     * @param m the element to add.
     */
    public void add(final T m) {
        checkNotNull(m);
        synchronized (tm) {
            tm.put(m, m);
        }
    }


    /**
     * Remove an element from the heap.  Will throw a runtime exception
     * when attempting to remove something that isn't stored in the heap.
     * @param m the item to remove.
     */

    public void remove(final T m) {
        checkNotNull(m);
        synchronized (tm) {
            if (!tm.containsKey(m)) {
                throw new RuntimeException(
                        "Attempt to remove nonexisting "
                        + "content from a SimulatedHeap");
            }

            checkArgument(true);
            checkArgument(tm.containsKey(m));
            final int size = tm.size();
            tm.remove(m);
            assert (size - 1 == tm.size());
        }
    }

    /**
     * Get the first element of the heap (the smallest element).
     * @return the smallest element of the heap.
     */
    public T getFirst() {
        synchronized (tm) {
            return tm.get(tm.firstKey());
        }
    }

    /**
     * True iff the heap contains no elements.
     * @return true iff empty.
     */
    public boolean isEmpty() {
        synchronized (tm) {
            return tm.isEmpty();
        }
    }

    @Override
    public String toString() {
        synchronized (tm) {
            return "SimulatedHeap{" + "tm=" + tm + '}';
        }
    }

    /**
     * True iff the heap contains element m.
     * @param m the element to check for.
     * @return True iff the element is there.
     */
    public boolean contains(final T m) {
        synchronized (tm) {
            return tm.containsKey(m);
        }
    }

    /**
     * Returns the number of element in the heap.
     * @return no of elements in the heap.
     */
    public int size() {
        synchronized (tm) {
            return tm.size();
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.utils;

import static com.google.common.base.Preconditions.checkNotNull;
import java.util.Comparator;
import java.util.concurrent.PriorityBlockingQueue;

/**
 * Simulating a heap using a PriorityBlockingQueue.
 *
 * @param <T> The type of the elements in the simulated heap.
 */
public final class SimulatedHeapConcurrent<T> {

    private static final int INITIAL_CAPACITY = 2;

    /**
     * We use a TreeMap to represent the heap.
     */
    private final PriorityBlockingQueue<T> pbq;

   /**
    * Create a new simulated heap using the comparator c.
    * @param c a comparator of T elements.
    */
    public SimulatedHeapConcurrent(final Comparator<T> c) {
        checkNotNull(c);
        pbq = new PriorityBlockingQueue<>(INITIAL_CAPACITY, c);
    }

    /**
     * Add an element to the heap.
     * @param m the element to add.
     */
    public void add(final T m) {
        checkNotNull(m);
        pbq.put(m);
    }

    /**
     * Remove an element from the heap.  Will throw a runtime exception
     * when attempting to remove something that isn't stored in the heap.
     * @param m the item to remove.
     */

    public void remove(final T m) {
        checkNotNull(m);

        if (pbq.isEmpty()) {
            throw new RuntimeException(
                    "Attempt to remove content from empty queue");
        }
        if (!pbq.remove(m)) {
            throw new RuntimeException(
                    "Attempt to remove nonexisting "
                    + "content from a SimulatedHeap");
        }
    }


    /**
     * Get the first element of the heap (the smallest element).
     * @return the smallest element of the heap.
     */
    public T getFirst() {
        return pbq.peek();
    }

    /**
     * True iff the heap contains no elements.
     * @return true iff empty.
     */
    public boolean isEmpty() {
        return pbq.isEmpty();
    }

    @Override
    public String toString() {
        return "SimulatedHeap{" + "tm=" + pbq + '}';
    }

    /**
     * True iff the heap contains element m.
     * @param m the element to check for.
     * @return True iff the element is there.
     */
    public boolean contains(final T m) {
        return pbq.contains(m);
    }

    /**
     * Returns the number of element in the heap.
     * @return no of elements in the heap.
     */
    public int size() {
        return pbq.size();
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.utils;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * A counter that will give integer values starting from zero.
 */
public final class Counter {

    /**
     * True iff counter can be decremented.
     */
    private final boolean canBeDecremented;
    /**
     * Name of the counter. Lives in a global address space so all counter names
     * has to be unique.
     */
    private final String name;

    /**
     * A monitor used to regulate access to the counter.
     */
    private final Object monitor = new Object();

    private final AtomicInteger atomicInt = new AtomicInteger(0);

    /**
     * Create a new counter. The name needs to be unique. By default counters
     * can be both incremented and decremented.
     *
     * @param name The name of the counter.
     * @param canBeDecremented
     */
    public Counter(final String name, final boolean canBeDecremented) {
        this.name = checkNotNull(name, "Counter name can't be null").trim();
        this.canBeDecremented = canBeDecremented;
        checkArgument(name.length() != 0, "Counter name can't be empty string");
    }

    public Counter(final String name) {
        this(name, false);
    }

    /**
     * Increment the counter by one and return the new value.
     *
     * @return the new value.
     */
    public long inc() {
        return atomicInt.addAndGet(1);
    }

    /**
     * Decrement the counter by one and return the new value.
     *
     * @return the new value.
     */
    public long dec() {

        if (!canBeDecremented) {
            throw new IllegalStateException(
                    "Can't decrement a counter that can't be decremented");
        }
        return (atomicInt.addAndGet(-1));
    }


    @Override
    public String toString() {
        synchronized (monitor) {
            return "#'" + name + "'=" + atomicInt;
        }
    }
}


package no.rmz.rmatch.utils;

import java.util.logging.Level;
import java.util.logging.Logger;
import no.rmz.rmatch.interfaces.Action;
import no.rmz.rmatch.interfaces.Buffer;

/**
 * Simple utility action used to count the number of something.
 */
public final class CounterAction implements Action {

    /**
     * Our dear old Log.
     */
    private static final Logger LOG =
            Logger.getLogger(CounterAction.class.getName());
    /**
     * How long to wait between reports.
     */
    private static final int
            DEFAULT_TICK_INTERVAL_FOR_IN_ACTIONS_BETWEEN_REPORTS = 4000;
    /**
     * Should the reports be verbose?
     */
    private final boolean verbose = true;
    /**
     * Monitor used to synchronize access.
     */
    private final Object monitor = new Object();
    /**
     * The value of the counter.
     */
    private int counter = 0;
    /**
     * The tick interval we'll actually use.
     */
    private final int tickInterval =
            DEFAULT_TICK_INTERVAL_FOR_IN_ACTIONS_BETWEEN_REPORTS;
    /**
     * Initialize the timestamp for the last tick to be the time of class
     * initialization.
     */
    private long lastTick = System.currentTimeMillis();

    @Override
    public void performMatch(final Buffer b, final int start, final int end) {
        synchronized (monitor) {
            counter += 1;

            if (verbose && (counter % tickInterval) == 0) {

                // Collecting a report from the known counters
                final StringBuilder sb = new StringBuilder();
                for (final Counter c : Counters.getCounters()) {
                    sb.append("  ").append(c.toString()).append(", ");
                }

                // Making a report for the current counter,
                // plus all the counters.
                long now = System.currentTimeMillis();
                long duration = now - lastTick;
                double speed = duration / (double) tickInterval;

                LOG.log(Level.INFO, "Match counter == {0}, duration = {1}, speed = {2} millis/tick, start/end = {3}/{4}, match string = ''{5}'' {6}", new Object[]{counter, duration, speed, start, end, b.getString(start, end + 1), sb.toString()});
                lastTick = now;

            }
        }
    }

    /**
     * Return the number of matches that has been performed on this action.
     *
     * @return an integer.
     */
    public int getCounter() {
        synchronized (monitor) {
            return counter;
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package no.rmz.rmatch.utils;

import java.io.Serializable;
import java.util.Comparator;
import java.util.Iterator;
import java.util.SortedSet;

/**
 * Implements a comparator for sorted sets of T. All the elements in the set
 * must be comparable, and since the sets are sortable we can traverse the
 * elements in lexographical order. The first set to contain something the other
 * set doesn't contain is larger than the other.
 *
 * @param <T>
 */
public final class SortedSetComparatorImpl<T extends Comparable>
        implements Comparator<SortedSet<T>>, Serializable {

    @Override
    public int compare(final SortedSet<T> t, final SortedSet<T> t1) {
        final Iterator<T> ti  = t.iterator();
        final Iterator<T> t1i = t1.iterator();

        while (ti.hasNext() && t1i.hasNext()) {
            int r = ti.next().compareTo(t1i.next());
            if (r != 0) {
                return r;
            }
        }

        if (!ti.hasNext() && !t1i.hasNext()) {
            return 0;
        } else if (ti.hasNext()) {
            return 1;
        } else {
            return -1;
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.abstracts;

import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.PrintableEdge;
import no.rmz.rmatch.interfaces.Regexp;
import no.rmz.rmatch.utils.Counter;
import no.rmz.rmatch.utils.Counters;
import no.rmz.rmatch.utils.LifoSet;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * An abstract implementation of the NDANode interface. In fact, this
 * implementation is designed so that only the getNextNDFA and getEdgesToPrint
 * methods should be implemented by subclasses.
 */
public abstract class AbstractNDFANode implements NDFANode {
    /**
     * Count the number of abstract ndfanodes we crate. This counter is used for
     * many things, not just for instrumentation. It is also used to generate
     * graphviz graphs and uniquely identify NDFAs in various contexts.
     */
    static final Counter COUNTER = Counters.newCounter("AbstractNDFANodes");
    /**
     * A counter that keeps track of how many edges that has been observed out
     * of this NDFA.
     */
    private static final Counter cachedEdgesCounter =
 Counters.newCounter("Cached edges going to an NDFA.");



    /**
     * A cache of the next sets.  This is a cache that is used to avoid
     * recomputing the next set for a given character.  The cache is
     * thread safe, and is implemented as a ConcurrentHashMap.
     */
    final ConcurrentHashMap<Character, SortedSet<NDFANode>>  nextSetCache = new ConcurrentHashMap<>();

    /**
     * The set of epsilon-edges going out of this node.
     */
    private final SortedSet<NDFANode> epsilonSet = new TreeSet<>();
    /**
     * The regular expression associated with this NDFA.
     */
    private final Regexp regexp;
    /**
     * True iff this ndfa is terminal for the regexp.
     */
    private final boolean isTerminal;
    /**
     * True iff reaching this node means that a match MUST fail.
     */
    private final boolean isFailing;
    /**
     * Monitor used to synchronize access to single methods.
     */
    protected final Object monitor = new Object();
    /**
     * An unique index for the Abstract DNFANodes. Generated by a counter.
     */
    private final Long index;


    /**
     * Create a new AbstractNDFANode instance.
     *
     * @param r the regular expression associated with this node.
     * @param isTerminal Is this node terminal for the regexp?
     * @param isFailing true iff visiting this node means that a match will
     * fail!
     */
    public AbstractNDFANode(
            final Regexp r,
            final boolean isTerminal,
            final boolean isFailing) {
        this.regexp = checkNotNull(r, "Regexp can't be null for an NDFA node");
        this.isTerminal = isTerminal;
        this.isFailing = isFailing;

        this.index = COUNTER.inc();

        if (isTerminal) {
            r.addTerminalNode(this);
        }
    }

    @Override
    public int hashCode() {
        return index.hashCode();
    }

    @Override
    public boolean equals(final Object o) {
        if (o instanceof AbstractNDFANode) {
            final AbstractNDFANode other = (AbstractNDFANode) o;
            return index.equals(other.index);
        } else {
            return false;
        }
    }



    /**
     * Create a new AbstractNDFANode instance.
     *
     * @param r the regular expression associated with this node.
     * @param isTerminal Is this node terminal for the regexp?
     */
    public AbstractNDFANode(
            final Regexp r,
            final boolean isTerminal) {
        this(r, isTerminal, false);
    }

    /**
     * Return an id that is unique for this NDFA instance.
     *
     * @return a long identifying the node.
     */
    public final Long getId() {
        // This doesn't need to be locked, since it is immutable.
        return index;
    }

    @Override
    public final boolean isTerminal() {
        return isTerminal;
    }

    @Override
    public final Regexp getRegexp() {
        return regexp;
    }

    @Override
    public final boolean isActiveFor(final Regexp rexp) {
        return rexp.isActiveFor(this);
    }

    @Override
    public final boolean isTerminalFor(final Regexp rexp) {
        return rexp.hasTerminalNdfaNode(this);
    }

    @Override
    public final boolean isFailing() {
        return isFailing;
    }

    /**
     * Implement breadth first search through the set of nodes for NDFA nodes
     * that are valid successors to the current node, through the parameter
     * "ch".
     *
     * @param ch the char we're finding the set of NDFAs for.
     * @return a set of NDFA nodes representing the next state for the DFA.
     */
    @Override
    public final SortedSet<NDFANode> getNextSet(final Character ch) {
       return  nextSetCache.computeIfAbsent(ch, this::getNextSetNonThreadsafe);
    }


    /**
     * Implement breadth first search through the set of nodes for NDFA nodes
     * that are valid successors to the current node, through the parameter
     * "ch".
     *
     * @param ch the char we're finding the set of NDFAs for.
     * @return a set of NDFA nodes representing the next state for the DFA.
     */
    private SortedSet<NDFANode> getNextSetNonThreadsafe(final Character ch) {

        // Eventually, the result we'll collect and return will go into this
        // set.
        final SortedSet<NDFANode> resultNodes = new TreeSet<>();

        // Meanwhile, we'll have a set of unexplored nodes that we'll have to
        // explore before we're done.
        final LifoSet<NDFANode> unexploredNodes = new LifoSet<>();

        // The set of unexplored nodes start with the current node.
        unexploredNodes.add(this);

        final Set<NDFANode> visitedNodes = new HashSet<>();

        while (!unexploredNodes.isEmpty()) {

            // Get the first NDFA node
            final NDFANode current = unexploredNodes.pop();
            visitedNodes.add(current);

            // By pursuing the current NDFA node through both
            // character-specific and epsilon edges, we get
            // a new NDFA node that is reachble through this character.
            // If we  haven't expored this node, so we add it to the
            // set of unexplored nodes.
            final NDFANode nextNode = current.getNextNDFA(ch);

            if (nextNode != null) {
                resultNodes.add(nextNode);
            }

            final Set<NDFANode> newNodes
                    = extendByFollowingEpsilons(current);

            // Remove new nodes that are already in the resultNodes
            removeDuplicates(newNodes, resultNodes);

            if (!newNodes.isEmpty()) {
                newNodes.removeAll(visitedNodes);
                unexploredNodes.addAll(newNodes);
            }
        }

        followEpsilonLinks(resultNodes);

        // Updating the counter.
        cachedEdgesCounter.inc();


        // The set of NDFANode instances
        // representing the next DFA node.
        return resultNodes;
    }

    private static void removeDuplicates(
            final Set<NDFANode> newNodes,
            final SortedSet<NDFANode> resultNodes) {
        if (!newNodes.isEmpty() && !resultNodes.isEmpty()) {
            newNodes.removeAll(resultNodes);
        }
    }

    private Set<NDFANode> extendByFollowingEpsilons(final NDFANode current) {
        // Now we calculate a set difference between the  nodes
        // that can be reached from the current node through its
        // epsilons, and all the nodes we have already put into the
        // result set.   The difference is added to the
        // set of unexplored nodes.
        final Set<NDFANode> newNodes = new HashSet<>();
        final Set<NDFANode> epsilons = current.getEpsilons();
        if (!epsilons.isEmpty()) {
            newNodes.addAll(epsilons);
        }
        return newNodes;
    }

    /**
     * Then follow all epsilon links for the nodes in the resultNodes set
     * (transitively reflexive closure of epsilon links) and add all of those to
     * the result set.
     */
    private static void followEpsilonLinks(final SortedSet<NDFANode> resultNodes) {

        final Set<NDFANode> epsilonClosure = new HashSet<>();
        for (final NDFANode r : resultNodes) {
            epsilonClosure.addAll(r.getEpsilons());
        }

        while (!epsilonClosure.isEmpty()) {
            final NDFANode next = epsilonClosure.iterator().next();
            if (resultNodes.add(next)) {
                epsilonClosure.addAll(next.getEpsilons());
            }
            epsilonClosure.remove(next);
        }
    }

    @Override
    public final SortedSet<NDFANode> getEpsilons() {
        synchronized (monitor) {
            return Collections.unmodifiableSortedSet(epsilonSet);
        }
    }

    @Override
    public final void addEpsilonEdge(final NDFANode n) {
        synchronized (monitor) {
            checkNotNull(n,
                    "It is meaningless to add a NULL NDFANode "
                    + "as an epsilon reachable node");
            epsilonSet.add(n);
        }
    }

    @Override
    public final void removeEpsilonReachableNode(final NDFANode n) {
        synchronized (monitor) {
            epsilonSet.remove(n);
        }
    }

    @Override

    public final int compareTo(final NDFANode t) {
        if (!(t instanceof AbstractNDFANode)) {
            throw new UnsupportedOperationException("Not supported yet.");
        } else {
            final AbstractNDFANode ta = (AbstractNDFANode) t;

            return index.compareTo(ta.index);
        }
    }

    /**
     * Add a bunch of nodes that can be epsilon-reached.
     *
     * @param alternatives A set of epsilon-reachable nodes.
     */
    public final void addEpsilonReachableNodes(
            final Collection<NDFANode> alternatives) {
        synchronized (monitor) {
            for (final NDFANode n : alternatives) {
                addEpsilonEdge(n);
            }
        }
    }

    /**
     * This method is intended to be overridden. The subclass should first call
     * its superclass's getEdgesToPring method, to get all the epsilon edges,
     * and anything else the superclass chooses to include, and then add
     * whatever edges that the getNextNDFA method can link to.
     *
     * @return A collection of PrintableEdge instances.
     */
    public final Collection<PrintableEdge> getEpsilonEdgesToPrint() {
        final Collection<PrintableEdge> result = new ArrayList<>();
        synchronized (monitor) {
            for (final NDFANode n : epsilonSet) {
                result.add(new PrintableEdge(null, n));
            }
        }
        return result;
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import no.rmz.rmatch.interfaces.NDFACompiler;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.Regexp;
import no.rmz.rmatch.interfaces.RegexpStorage;

/**
 * An implementation of a compiler.
 */
public final class NDFACompilerImpl implements NDFACompiler {

    @Override
    public NDFANode compile(
            final Regexp regexp,
            final RegexpStorage rs) throws RegexpParserException {
        final ARegexpCompiler arc = new ARegexpCompiler(regexp);
        final SurfaceRegexpParser surfaceRegexpParser =
                new SurfaceRegexpParser(arc);
        surfaceRegexpParser.parse(regexp.getRexpString());
        return arc.getResult();
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

/**
 * Exception thrown when we discover some error during parsing of a regular
 * expression.
 */
public final class RegexpParserException extends Exception {

    /**
     * Something went bad when parsing a regexp.
     * @param msg an explanation of what went wrong.
     */
    public RegexpParserException(final String msg) {
        super(msg);
    }

    /**
     * An exception caused the parsing to go wrong, this is
     * that exception wrapped as a RegexpParserException.
     * @param e the cause of evil.
     */
    public RegexpParserException(final Exception e) {
        super(e);
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import java.util.Collection;
import no.rmz.rmatch.abstracts.AbstractNDFANode;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.PrintableEdge;
import no.rmz.rmatch.interfaces.Regexp;

/**
 * Create a  node that when reached will fail the regexp.  This node
 * has no outgoing nodes, except for epsilon nodes.
 */
final class FailNode extends AbstractNDFANode {

    /**
     * Create a new failing node.
     * @param r for this instance
     */
    FailNode(final Regexp r) {
        super(r, false, true);
        // XXX Time to make a builder?
    }

    @Override
    public NDFANode getNextNDFA(final Character ch) {
        return null;
    }

    @Override
    public Collection<PrintableEdge> getEdgesToPrint() {
        return getEpsilonEdgesToPrint();
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import static com.google.common.base.Preconditions.*;

// XXX This looks really stupid!

/**
 * A source of character used by the compiler to get input characters.
 */
public final class StringSource {

    /**
     * The string we're getting the characters from.
     */
    private final String string;

    /**
     * The current index into the string.
     */
    private int index;

    /**
     * The length of the string.
     */
    private final int len;

    /**
     * Create a new instance of the StringSource.
     * @param string ther string we will be getting characters from.
     */
    public StringSource(final String string) {
        this.string = checkNotNull(string);
        this.index = 0;
        this.len = string.length();
    }

    /**
     * Are there more characters?
     * @return true iff more chars to read.
     */
    public boolean hasNext() {
        return index < len;
    }

    /**
     * Get next character and increment index.
     * @return the next character.
     */
    public char next() {
        return string.charAt(index++);
    }

    /**
     * If more characters after thd current, then return then return the
     * next character without advancing the index pointer, otherwise return
     * null.
     * @return next character or null if there are no more characters to read.
     */
    public Character peek() {
        if (hasNext()) {
            return string.charAt(index);
        } else {
            return null;
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import static com.google.common.base.Preconditions.checkNotNull;
import java.util.Collection;
import no.rmz.rmatch.abstracts.AbstractNDFANode;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.PrintableEdge;
import no.rmz.rmatch.interfaces.Regexp;

/**
 * A node that matches any character.
 */
public final class AnyCharNode extends AbstractNDFANode {

    /**
     * The node to go to after matching the input character.
     */
    private final NDFANode nextNode;

    /**
     * Create a new "any" node matching any character.
     *
     * @param nextNode The character to go to after matching any character.
     * @param r The regexp that this node is a part of the representation for.
     */
    public AnyCharNode(final NDFANode nextNode, final Regexp r) {
        super(r, false);
        this.nextNode = checkNotNull(nextNode);
    }

    @Override
    public NDFANode getNextNDFA(final Character ch) {
        return nextNode;
    }

    @Override
    public Collection<PrintableEdge> getEdgesToPrint() {
        final Collection<PrintableEdge> result = getEpsilonEdgesToPrint();
        result.add(new PrintableEdge(".", nextNode));
        return result;
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import static com.google.common.base.Preconditions.checkNotNull;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.Regexp;

/**
 * A (partial) compiler that will produce NDFAs that represents regular
 * expressions. The compiler implements the AbstractRegexBuilder interface which
 * will feed it with parsed elements of the regexp.
 */
public final class ARegexpCompiler implements AbstractRegexBuilder {

    /**
     * A builder for alternatives. By default we will assume that we are
     * building an alternative, so this builder ends up consuming most of the
     * input and returning the final result.
     */
    final AlternativesBuilder alternativesBuilder;
    /**
     * The last, and hence an epsilon-node going out of the last element of the
     * resultFragments.
     */
    private final TerminalNode terminal;
    /**
     * The regexp we're compiling.
     */
    private final Regexp regexp;
    /**
     * When building a character set, we use this builder instance to do it for
     * us. A new instance for each char set.
     */
    private CharSetBuilder charSetStringBuilder;

    /**
     * Create a new compiler for a particular regexp.
     *
     * @param regexp The Regexp we are compiling.
     */
    public ARegexpCompiler(final Regexp regexp) {
        this.regexp = checkNotNull(regexp);
        this.terminal = new TerminalNode(regexp);
        this.alternativesBuilder = new AlternativesBuilder(regexp);

    }

    /**
     * XXX Once this method has been called, no further content can be added.
     * This is currently not reflected in the implementations, so errors can be
     * introduced!!! must be fixed asap.
     *
     * @return Returns an NDFANode that represent the compilation of the regexp.
     */
    public NDFANode getResult() {
        final CompiledFragment result = alternativesBuilder.build();
        result.getEndingNode().addEpsilonEdge(terminal);
        return result.getArrivalNode();
    }

    @Override
    public void addString(final String str) {
        final CompiledFragment result = new CompiledFragment(regexp);
        final NDFANode arrival = result.getArrivalNode();
        final NDFANode endNode = result.getEndingNode();

        // Produce a chain of nodes linked by the next character.
        // build the chain backwards from the last char in the string
        // back to the first chracter in the string.
        NDFANode nextNode = endNode;
        for (int i = str.length() - 1; i >= 0; i--) {
            final Character myChar = str.charAt(i);
            nextNode = new CharNode(nextNode, myChar, regexp);
        }

        // Finally hook the  arrival node of the result up to
        // the first node in the chain representing the string.
        arrival.addEpsilonEdge(nextNode);


        // If there are no alternatives accumulated so far, or we've just
        // seen a newAlternative been set, start a new alternative,
        // otherwise we append the NDFA representing
        // the string to the end of the last node in the current set of
        // alternatives.
        alternativesBuilder.addLast(result);
    }

    @Override
    public void separateAlternatives() {
        alternativesBuilder.separateAlternatives();
    }

    @Override
    public void startCharSet() {
        charSetStringBuilder = new CharSetBuilder(regexp);
    }

    @Override
    public void endCharSet() {
        final CompiledFragment result = charSetStringBuilder.build();
        alternativesBuilder.addLast(result);
    }

    @Override
    public void invertCharSet() {
        charSetStringBuilder.invert();
    }

    @Override
    public void addToCharSet(final String cs) {
        charSetStringBuilder.addChars(cs);
    }

    @Override
    public void addRangeToCharSet(
            final char startOfRange,
            final char endOfRange) {
        charSetStringBuilder.addRange(startOfRange, endOfRange);
    }

    @Override
    public void addAnyChar() {
        final CompiledFragment fragment = new CompiledFragment(regexp);
        final NDFANode resultNode =
                new AnyCharNode(fragment.getEndingNode(), regexp);
        fragment.getArrivalNode().addEpsilonEdge(resultNode);
        alternativesBuilder.addLast(fragment);
    }

    @Override
    public void addBeginningOfLine() {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void addEndOfLine() {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void addOptionalSingular() {
        final CompiledFragment last = alternativesBuilder.getLastFragment();
        last.getArrivalNode().addEpsilonEdge(last.getEndingNode());
    }

    @Override
    public void addOptionalZeroOrMulti() {
        final CompiledFragment last = alternativesBuilder.getLastFragment();
        last.getArrivalNode().addEpsilonEdge(last.getEndingNode());
        last.getEndingNode().addEpsilonEdge(last.getArrivalNode());
    }

    @Override
    public void addOptionalOnceOrMulti() {
        final CompiledFragment last = alternativesBuilder.getLastFragment();
        last.getEndingNode().addEpsilonEdge(last.getArrivalNode());
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

/**
 * A intermidate structure used by the compiler to represent ranges of
 * characters.
 */
public final class CharRange implements Comparable<CharRange> {

    /**
     * The smallest character in the range.
     */
    private final Character start;
    /**
     * The largest character in the range.
     *
     */
    private final Character end;

    /**
     * Create a new character range.
     *
     * @param start The smallest character in the range.
     * @param end The largest character in the range.
     */
    public CharRange(final Character start, final Character end) {
        this.start = start;
        this.end = end;
    }

    /**
     * The smallest character in the range.
     *
     * @return the smallest char.
     */
    public Character getStart() {
        return start;
    }

    /**
     * Get the largest character in the range.
     *
     * @return the largest char.
     */
    public Character getEnd() {
        return end;
    }

    @Override
    public int compareTo(final CharRange that) {

       int r = start.compareTo(that.start);
       if (r != 0) {
           return r;
       }

       return end.compareTo(that.end);
    }

    @Override
    public boolean equals(final Object o) {
        if (o instanceof CharRange) {
            final CharRange that = (CharRange) o;
            return (this.start.equals(that.start)
                    && this.end.equals(that.end));
        } else {
            return false;
        }
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 37 * hash + (this.start != null ? this.start.hashCode() : 0);
        hash = 37 * hash + (this.end != null ? this.end.hashCode() : 0);
        return hash;
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import java.util.Collection;
import no.rmz.rmatch.abstracts.AbstractNDFANode;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.PrintableEdge;
import no.rmz.rmatch.interfaces.Regexp;

/**
 * A node that has an outgoing edge for a single, specific character.
 */
public final class CharNode extends AbstractNDFANode {

    /**
     * The node we will go to after matching this character.
     */
    private final NDFANode nextNode;
    /**
     * The specific character we are looking for.
     */
    private final Character ch;

    /**
     * Create a new node that will match a specific character.
     *
     * @param nextNode The node we will go to after matching this character.
     * @param ch The specific character we are looking for.
     * @param r The regexp we are matching for.
     */
    public CharNode(
            final NDFANode nextNode,
            final Character ch,
            final Regexp r) {
        this(nextNode, ch, r, false);
    }

    /**
     * Create a new node that will match a specific character.
     *
     * @param nextNode The node we will go to after matching this character.
     * @param ch The specific character we are looking for.
     * @param r The regexp we are matching for.
     * @param isTerminal True iff this node is terminal
     */
    private CharNode(
            final NDFANode nextNode,
            final Character ch,
            final Regexp r,
            final boolean isTerminal) {
        super(r, isTerminal);
        this.nextNode = nextNode;
        this.ch = ch;
    }

    @Override
    public NDFANode getNextNDFA(final Character chr) {
        if (ch.equals(chr)) {
            return nextNode;
        } else {
            return null;
        }
    }

    @Override
    public Collection<PrintableEdge> getEdgesToPrint() {
        synchronized (monitor) {
            final Collection<PrintableEdge> result = getEpsilonEdgesToPrint();
            result.add(new PrintableEdge(String.valueOf(ch), nextNode));
            return result;
        }
    }
}


package no.rmz.rmatch.compiler;

import no.rmz.rmatch.abstracts.AbstractNDFANode;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.PrintableEdge;
import no.rmz.rmatch.interfaces.Regexp;
import org.jetbrains.annotations.NotNull;

import java.util.Collection;
import java.util.Set;
import java.util.TreeSet;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * A builder for a CharSet.
 */
public final class CharSetBuilder {

    /**
     * The set of characters that this builder will look for.
     */
    private final StringBuilder charSetStringBuilder = new StringBuilder();

    /**
     * A collection of char-ranges that this matcher will look for.
     */
    private final Set<CharRange> charRanges = new TreeSet<>();

    /**
     * True iff this CharSet should be treated as an "inverted" CharSet,
     * i.e. one that will match everything -except- the characters in
     * the char set represented by the CharSet.
     */
    private boolean isInverted;

    /**
     *  The regexp that contains this CharSet.
     */
    private final Regexp regexp;

    /**
     * Create a new CharSet builder for a regexp.
     * @param regexp The regexp that the char set is a part of.
     */
    public CharSetBuilder(final Regexp regexp) {
        this.regexp = checkNotNull(regexp);
        isInverted = false;
    }

    /**
     * Build a CompiledFragment that represents the CharSet.
     * @return the compilation result.
     */
    public CompiledFragment build() {
        final CompiledFragment result = new CompiledFragment(regexp);
        final NDFANode arrival = result.getArrivalNode();
        final NDFANode endNode = result.getEndingNode();
        final String str = charSetStringBuilder.toString();
        final NDFANode intermediateNode;


        // If we're compiled an inverted set, then  create a graph that
        // will let any character pass but if we get one of the
        // characters of the character set, then we will fail the match
        // by getting to  a failing node.
        if (isInverted) {
            intermediateNode = createInvertedMatch(arrival, endNode);
        } else {
            intermediateNode = endNode;
        }

        // To match, make an NDFA node per character in the set
        // and pass through to the intermediate node if matching
        // one of the chars.
        for (int i = str.length() - 1; i >= 0; i--) {
            final char myChar = str.charAt(i);
            final NDFANode node =
                    new CharNode(intermediateNode, myChar, regexp);
            arrival.addEpsilonEdge(node);
        }

        // Add more opportunities to match by  NDFA node per range in the set
        // and pass through to the intermediate node if matching
        // one of the ranges.
        for (final CharRange range : charRanges) {
            final NDFANode node =
                    new CharRangeNode(range, regexp, intermediateNode);
            arrival.addEpsilonEdge(node);
        }

        return result;
    }

    @NotNull
    private NDFANode createInvertedMatch(NDFANode arrival, NDFANode endNode) {
        final NDFANode intermediateNode;
        final NDFANode failingMatchNode = new FailNode(regexp);
        intermediateNode = failingMatchNode;
        final NDFANode gettingThroughAnyhow =
                new AbstractNDFANode(regexp, false) {
                    @Override
                    public NDFANode getNextNDFA(final Character ch) {
                        return endNode;
                    }

                    @Override
                    public Collection<PrintableEdge> getEdgesToPrint() {
                        final Collection<PrintableEdge> result =
                                getEpsilonEdgesToPrint();
                        result.add(new PrintableEdge(".", endNode));
                        return result;
                    }
                };
        arrival.addEpsilonEdge(gettingThroughAnyhow);
        return intermediateNode;
    }

    /**
     * Add a bunch of characters to the set we're matching.
     * @param cs characters in a string ;)
     */
    void addChars(final String cs) {
        charSetStringBuilder.append(cs);
    }

    /**
     * Treat this set of characters inverted.
     */
    void invert() {
        isInverted = true;
    }

    /**
     * Add a range of characters.
     * @param startOfRange The first character in the range.
     * @param endOfRange The last character in the range.
     */
    void addRange(final char startOfRange, final char endOfRange) {
        charRanges.add(
                new CharRange(startOfRange, endOfRange));
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import java.util.LinkedList;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.Regexp;

/**
 * Compute a CompiledFragment that represents a set of alternatives, e.g.
 * "a|b|c".
 */
public final class AlternativesBuilder {

    /**
     * The Regexp instance for which this builder compiles a fragment.
     */
    private final Regexp regexp;
    /**
     * True iff the result has already been computed and returned.
     */
    private boolean hasBeenBuilt = false;
    /**
     * True iff we should treat the next input as a new alternative.
     */
    private boolean newAlternative = true;
    /**
     * This will be the result of the compilation. The actual result returned by
     * the getResult method is the arrival node of the first CompiledFeragment.
     */
    private final LinkedList<CompiledFragment> alternatives =
            new LinkedList<>();
    /**
     * A reference to the last fragment added, or null if we are parsing a new
     * alternative.
     */
    private CompiledFragment lastFragment;

    /**
     * Construct a new alternatives builder for a regexp.
     *
     * @param regexp the regexp that the alternatives will be a part of.
     */
    public AlternativesBuilder(final Regexp regexp) {
        this.regexp = checkNotNull(regexp);
    }

    /**
     * Build a compiled fragment based on the alternatives.
     *
     * @return a compilation result
     */
    public CompiledFragment build() {
        checkState(!hasBeenBuilt,
                "Attempt to build an alrady built AlternativesBuilder");
        wrapSequenceOfFragmentIntoFragment();
        final CompiledFragment result = new CompiledFragment(regexp);
        final NDFANode arrival = result.getArrivalNode();
        final NDFANode endNode = result.getEndingNode();
        for (final CompiledFragment f : alternatives) {
            arrival.addEpsilonEdge(f.getArrivalNode());
            f.getEndingNode().addEpsilonEdge(endNode);
        }
        hasBeenBuilt = true;
        return result;
    }

    /**
     * When starting a new alternative, the old sequence of patterns must be
     * wrapped into a CompiledFragment representing the alternative. This method
     * does that by performing a bit of surgery on the list.
     */
    private void wrapSequenceOfFragmentIntoFragment() {
        if (lastFragment != null) {
            final CompiledFragment alternative = new CompiledFragment(regexp);
            final CompiledFragment alternativeHead = alternatives.getLast();
            alternative.getArrivalNode()
                    .addEpsilonEdge(alternativeHead.getArrivalNode());
            lastFragment.getEndingNode()
                    .addEpsilonEdge(alternative.getEndingNode());
            alternatives.removeLast();
            alternatives.add(alternative);
        }
    }

    /**
     * Add a new fragment to the set of alternatives. Add it to the current
     * alternative being built, or create a new one if instructed to by having
     * the newAlternative flag set.
     * @param  fragment fragment to add after the last one.
     */
    public void addLast(final CompiledFragment fragment) {

        checkState(!hasBeenBuilt,
                "Attempt to add more to an already built AlternativesBuilder");
        if (newAlternative) {
            wrapSequenceOfFragmentIntoFragment();

            alternatives.add(fragment);
            newAlternative = false;
        } else {
            lastFragment
                    .getEndingNode()
                    .addEpsilonEdge(fragment.getArrivalNode());
        }
        lastFragment = fragment;
    }

    /**
     * Return the last compiled fragment that was added.
     *
     * @return A compiled fragment.
     */
    public CompiledFragment getLastFragment() {
        checkState(!hasBeenBuilt,
                "Attempt extract something from "
                + "an already built AlternativesBuilder");
        return lastFragment;
    }

    /**
     * When separating alternatives, this method is called to make sure that the
     * next time addLast is added, the next element is added to a new
     * alternative.
     */
    public void separateAlternatives() {
        checkState(!hasBeenBuilt,
                "Attempt to add more to an already built AlternativesBuilder");
        wrapSequenceOfFragmentIntoFragment();
        lastFragment = null;
        newAlternative = true;
    }
}

/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

/**
 * This interface is used for builders of abstract syntax trees for regular
 * expressions. Its intended use is to be injected into a parser for the surface
 * syntax of regular expressions, which then parses that surface syntax, and
 * delegates to an AbstractRegexBuilder to build a proper abstract regular
 * expression tree. That tree is in turn sent over to a compiler that will
 * produce a more or less runnable representation of it, e.g. an NDFA.
 */
public interface AbstractRegexBuilder {

    /**
     * Add a string, to be treated as a sequence of individual characters.
     *
     * @param str a string of characters to add.
     */
    void addString(final String str);

    /**
     * When parsing a set of alternatives (e.g. "a|b|c"), this method is invoked
     * between each of the alternatives.
     */
    void separateAlternatives();

    /**
     * When parsing a char set (e.g. "[abc]", this method is invoked before the
     * body of the char set.
     */
    void startCharSet();

    /**
     * When parsing a char set, this method is invoked to indicate the end of
     * the char set parsing.
     */
    void endCharSet();

    /**
     * This method is invoked immediately after the invokation of the
     * "startCharSet" method, if the char set is encoded as an "inverse" char
     * set, i.e. one matching all other characters than the ones encoded by the
     * content of the char set (e.g. "[^a]" would match anything except the
     * letter "a"
     */
    void invertCharSet();

    /**
     * Add all the characters in the string are added to the char set.
     *
     * @param cs a string representing characters in a char seg.
     */
    void addToCharSet(final String cs);

    /**
     * A range matching all characters greather than or equal to the
     * startOfRange char, and less than or equal to the endOfRange.
     *
     * @param startOfRange Lirst character in range.
     * @param endOfRange Last character in range.
     */
    void addRangeToCharSet(final char startOfRange, final char endOfRange);

    /**
     * Add a pattern matching any char (".").
     */
    void addAnyChar();

    /**
     * Add a pattern matching the beginning of a line ("^").
     */
    void addBeginningOfLine();

    /**
     * Add a pattern matching the end of a line ("$").
     */
    void addEndOfLine();

    /**
     * Add a pattern matching an optional, but singular element: E.g. "a?"
     * denoting zero or one instances of the character "a".
     */
    void addOptionalSingular();

    /**
     * Add a pattern matching an element that should be repeated zero or many
     * times, e.g. "a*".
     */
    void addOptionalZeroOrMulti();

    /**
     * Add a pattern matching an element that should be repeated once or many
     * times, e.g. "a+".
     */
    void addOptionalOnceOrMulti();
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.Regexp;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * Represent a compiled fragment of a regexp.   In general there will be
 * an arrival node and an ending node.  There may or may not be some nodes
 * i between (usually there are) but these are typically generated by
 * a compiler, and then glued to the arrival and  ending nodes through
 * epsilon edges.
 */
public final class CompiledFragment {

    /**
     * The regexp for which this is a compilation fragment.
     */
    private final Regexp r;

    /**
     * The entry-point for this fragment's NDFA.
     */
    private final NDFANode arrivalNode;

    /**
     * If successful traversal of the NDFA, this node will be reached.
     */
    private final NDFANode endingNode;

    /**
     * Generate a new compiled fragment where all the components are
     * parameterized in the constructor.
     *
     * @param r The regexp for which this is a compilation fragment.
     * @param arrivalNode The entry-point for this fragment's NDFA.
     * @param endingNode If successful traversal of the NDFA,
     *                   this node will be reached.
     */
    public CompiledFragment(
            final Regexp r,
            final NDFANode arrivalNode,
            final NDFANode endingNode) {
        this.r = checkNotNull(r);
        this.arrivalNode = checkNotNull(arrivalNode);
        this.endingNode = checkNotNull(endingNode);
    }

    /**
     * Create a new CompiledFragement.  The arrival and ending nodes will
     * be new PaddingNDFANode instances.
     * @param r  the regex this fragment represents.
     */
    public CompiledFragment(final Regexp r) {
        this(r, new PaddingNDFANode(r), new PaddingNDFANode(r));
    }

    /**
     * Get the arrival node.
     * @return arrival node.
     */
    public NDFANode getArrivalNode() {
        return arrivalNode;
    }

    /**
     * Get the ending node.
     * @return endingNode.
     */
    public NDFANode getEndingNode() {
        return endingNode;
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import java.util.Collection;
import no.rmz.rmatch.abstracts.AbstractNDFANode;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.PrintableEdge;
import no.rmz.rmatch.interfaces.Regexp;

/**
 * This is a node that has only epsilon edges going into it and only epsilon
 * edges going out of it. It is used to pad other automata.
 */
public final class PaddingNDFANode extends AbstractNDFANode {

    /**
     * Create a new padding node for a regular expression.
     *
     * @param r Our regexp.
     */
    public PaddingNDFANode(final Regexp r) {
        super(r, false);
    }

    @Override
    public NDFANode getNextNDFA(final Character ch) {
        return null;
    }

    @Override
    public Collection<PrintableEdge> getEdgesToPrint() {
        return getEpsilonEdgesToPrint();
    }
}
/*
  Copyright 2012. Bjørn Remseth (rmz@rmz.no).

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */

package no.rmz.rmatch.compiler;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * A parser for regular expressions, will parse strings, and generate abstract
 * regular expression trees from those strings through an AbstractRegexBuilder.
 */
public final class SurfaceRegexpParser {

    /**
     * Boolean constants are poor man's enumerations. ;)
     */
    private static final boolean COMMIT_ONLY_IF_SOMETHING_IN_SB = true;

    /**
     * Another poor man's enum.
     */
    private static final boolean COMMIT_EMPTY_STRING_IF_NOTHING_IN_SB = false;

    /**
     * A recipient of abstract regexp syntax, used as a backend for
     * the compiler.
     */
    private final AbstractRegexBuilder arb;

    /**
     * Create a new parser with a ARB backend.
     *
     * @param arb Compiler backend.
     */
    public SurfaceRegexpParser(final AbstractRegexBuilder arb) {
        this.arb = checkNotNull(arb);

    }

    /**
     * Parse a string int a regular expression.
     *
     * @param regexString the string to parse.
     * @throws RegexpParserException when bd things happen.
     */
    public void parse(final String regexString)
            throws RegexpParserException {
        new PAux(regexString, arb).parse();
    }

    /**
     * A helper class used to parse regular expressions.
     */
    static final class PAux {

        /**
         * A compiler backend.
         */
        private final AbstractRegexBuilder arb;

        /**
         * A StringBuilder used to parse string segments in the input
         * regexp.
         */
        private StringBuilder sb;

        /**
         * A source of characters based on the input string.
         */
        private final StringSource src;

        /**
         * Create a new helper class instance.
         *
         * @param regexString the string to parse.
         * @param arb         the builder to use.
         */
        PAux(final String regexString, final AbstractRegexBuilder arb) {
            this.arb = checkNotNull(arb);
            this.sb = new StringBuilder();
            this.src = new StringSource(regexString);
        }

        /**
         * send the current string to the compiler backend, then
         * start a new StringBuilder.
         *
         * @param ifNotEmpty XXX Don't understand this.
         */
        private void commitCurrentString(final boolean ifNotEmpty) {
            final String str = sb.toString();
            if (ifNotEmpty) {
                if (str.isEmpty()) {
                    return;
                }
            }
            arb.addString(str);
            sb = new StringBuilder();
        }

        /**
         * The objective is to parse all legal regexps as described in
         * http://en.wikipedia.org/wiki/Regular_expression That's an interesting
         * goal in itself, however it may in fact be better to emulate java's
         * regexp syntax.
         * <p>
         * That's the lofty objectives, the reality is much more humble.
         * We can parse this expression "abc[ab][^de]z?f+x*|y" and expressions
         * containing the same constructs (character sequences,
         * character sets (and inverted sets), various optional subexpressions
         * of single-char length, and not much more.   This will eventually
         * change, but for now that's what we've got.
         *
         * @throws RegexpParserException when bad things happen during parsing.
         */
        void parse() throws RegexpParserException {
            while (src.hasNext()) {
                final char ch = src.next();
                parseNextChar(ch);
            }
            commitCurrentString(COMMIT_ONLY_IF_SOMETHING_IN_SB);
        }


        // XXX Missing {m,n}, meaning "match at least m,
        //     but no more than n times modifier.

        private void parseNextChar(char ch) throws RegexpParserException {
            switch (ch) {
                case '|':
                    commitCurrentString(COMMIT_EMPTY_STRING_IF_NOTHING_IN_SB);
                    arb.separateAlternatives();
                    break;
                case '\\':
                    parseQuotedChar();
                    break;
                case '.':
                    commitCurrentString(COMMIT_ONLY_IF_SOMETHING_IN_SB);
                    arb.addAnyChar();
                    break;
                case '^':
                    commitCurrentString(COMMIT_ONLY_IF_SOMETHING_IN_SB);
                    arb.addBeginningOfLine();
                    break;
                case '$':
                    commitCurrentString(COMMIT_ONLY_IF_SOMETHING_IN_SB);
                    arb.addEndOfLine();
                    break;
                case '?':
                    commitCurrentString(COMMIT_ONLY_IF_SOMETHING_IN_SB);
                    arb.addOptionalSingular();
                    break;
                case '*':
                    commitCurrentString(COMMIT_ONLY_IF_SOMETHING_IN_SB);
                    arb.addOptionalZeroOrMulti();
                    break;
                case '+':
                    commitCurrentString(COMMIT_ONLY_IF_SOMETHING_IN_SB);
                    arb.addOptionalOnceOrMulti();
                    break;
                case '[':
                    commitCurrentString(COMMIT_ONLY_IF_SOMETHING_IN_SB);
                    parseCharSet();
                    break;
                default:
                    sb.append(ch);
                    break;
            }
        }

        private void parseQuotedChar() throws RegexpParserException {
            char ch;
            if (src.hasNext()) {
                throw new RegexpParserException(
                        "Expected char after escape char: \\");
            }
            ch = src.next();
            sb.append(ch);
        }

        private void parseCharSet() throws RegexpParserException {
            char ch;
            arb.startCharSet();
            final Character nxt = src.peek();


            if (nxt == null) {
                throw new RegexpParserException(
                        "Unterminated char set, missing ']'");
            }

            if (nxt == '^') {
                arb.invertCharSet();
                src.next();
            }

            boolean parsingRange = false;
            while (src.hasNext()) {
                ch = src.next();
                if (ch == ']') {
                    break;
                } else if (ch == '-') {
                    parsingRange = true;
                } else if (parsingRange) {
                    final String s = sb.toString();
                    final int l = sb.length();
                    if (l > 1) {
                        arb.addToCharSet(s.substring(0, l - 1));
                    }
                    arb.addRangeToCharSet(s.charAt(l - 1), ch);
                    sb = new StringBuilder();
                    parsingRange = false;
                } else {
                    sb.append(ch);
                }
            }

            final String cs = sb.toString();
            if (!cs.isEmpty()) {
                arb.addToCharSet(cs);
                sb = new StringBuilder();
            }

            arb.endCharSet();
        }
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import static com.google.common.base.Preconditions.checkNotNull;
import java.util.Collection;
import no.rmz.rmatch.abstracts.AbstractNDFANode;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.PrintableEdge;
import no.rmz.rmatch.interfaces.Regexp;

/**
 * A node representing a char range.
 */
public final class CharRangeNode extends AbstractNDFANode {

    /**
     * The first character in the range.
     */
    private final Character start;
    /**
     * The last character in the range.
     */
    private final Character end;
    /**
     * The node to return if the input is within the range.
     */
    private final NDFANode next;

    /**
     * Create a node representing a char range.
     *
     * @param start The first character in the range.
     * @param end The last character in the range.
     * @param r The regular expression associated with this node.
     * @param next The node to return if the input is within the range.
     */
    public CharRangeNode(
            final Character start,
            final Character end,
            final Regexp r,
            final NDFANode next) {
        super(r, false);
        this.start = checkNotNull(start);
        this.end = checkNotNull(end);
        this.next = checkNotNull(next);
        if (start.compareTo(end) > 0) {
            // XXX Use something else than runtime exception.
            throw new RuntimeException("Cannot have char range in which "
                    + " end is  less than start");
        }
    }

    /**
     * Create a new range node.
     *
     * @param range The range from which we get the start and end of the range.
     * @param r the regexp we're working for.
     * @param next The next NDFANode to go to if the input char is within the
     * range.
     */
    public CharRangeNode(
            final CharRange range,
            final Regexp r,
            final NDFANode next) {
        this(range.getStart(), range.getEnd(), r, next);
    }

    @Override
    public NDFANode getNextNDFA(final Character ch) {
        if (start.compareTo(ch) <= 0 && ch.compareTo(end) <= 0) {
            return next;
        } else {
            return null;
        }
    }

    @Override
    public Collection<PrintableEdge> getEdgesToPrint() {
        final PrintableEdge printableEdge =
                new PrintableEdge(
                String.format("%c-%c", start, end),
                next);
        final Collection<PrintableEdge> result = getEpsilonEdgesToPrint();
        result.add(printableEdge);
        return result;
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.compiler;

import java.util.Collection;
import no.rmz.rmatch.abstracts.AbstractNDFANode;
import no.rmz.rmatch.interfaces.NDFANode;
import no.rmz.rmatch.interfaces.PrintableEdge;
import no.rmz.rmatch.interfaces.Regexp;

/**
 * A node that is terminal for the regexp it represents.
 */
public final class TerminalNode extends AbstractNDFANode {

    /**
     * Create a new instance of a terminal node for a regexp.
     *
     * @param r the regexp for which the new node is terminal.
     */
    public TerminalNode(final Regexp r) {
        super(r, true);
    }

    @Override
    public NDFANode getNextNDFA(final Character ch) {
        return null;
    }

    @Override
    public Collection<PrintableEdge> getEdgesToPrint() {
        return getEpsilonEdgesToPrint();
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import no.rmz.rmatch.compiler.RegexpParserException;

/**
 * A facade for the components of the matcher engine.
 */
public interface Matcher {

    /**
     * Add a regular expression to the matcher, and associate it with an action
     * to be run when the expression matches some input.
     *
     * @param r A regular expression.
     * @param a An action to run.
     * @throws no.rmz.rmatch.compiler.RegexpParserException
     */
    void add(final String r, final Action a) throws RegexpParserException;

    /**
     * Remove an association between a regular expression and an action from the
     * matcher.
     *
     * @param r A regular expression.
     * @param a An action.
     */
    void remove(final String r, final Action a);

    /**
     * Match all the regexps that are presently managed by the matcher and run
     * all the corresponding actions when matches are found.
     *
     * @param b a buffer that will provide the input to be matched against.
     */
    void match(final Buffer b);

    /**
     * Get the NodeStorage instance used by this matcher.
     *
     * @return a NodeStorage instance.
     */
    NodeStorage getNodeStorage();

    /**
     * Shut the matcher down nicely. If the matcher has internal threads, or
     * threadpools or anything else that needs an orderly shutdown, then this
     * method will handle that shutdown.
     *
     * @throws InterruptedException when bad things happen.
     */
    void shutdown() throws InterruptedException;
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * An edge used for printing. The label is a descriptive label describing what
 * type of input is necessary to traverse the edge. Typically it will be the
 * regular expression that triggers traversal, e.g. "[abc]", or "b" or
 * something. It will only be an expression representing a single character
 * though.
 */
public final class PrintableEdge {

    /**
     * A printable label, to be used by programs such as graphwiz to produce
     * nice readable representations of the NDFAs used by the program.
     */
    private final String label;
    /**
     * The target of the edge.
     */
    private final NDFANode destination;

    /**
     * A new printable edge, not used for matching but only for pretty printing
     * of the DNFA Graph.
     *
     * @param label A printable label, or null for epsilon edges.
     * @param destination The target for the edge.
     */
    public PrintableEdge(final String label, final NDFANode destination) {
        this.label = label;
        this.destination = checkNotNull(destination);
    }

    /**
     * Get the target (destination) of the edge.
     *
     * @return The target.
     */
    public NDFANode getDestination() {
        return destination;
    }

    /**
     * Get a descriptive label for the edge, typically a string like "a" or
     * "[foo]" or some other regular expression representing a single character.
     *
     * @return a nice descriptive string.
     */
    public String getLabel() {
        return label;
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

/**
 * A generic node used both in deterministic and nondeterminstic automata.
 */
public interface Node {

    /**
     * True iff the node is relevant for a regexp. The meaning is that if we for
     * some reason arrive at this node and is working on a match for a particuar
     * regexp, then we can continue to work on that match iff the node is active
     * for that regexp.
     *
     * @param r A regular expression representation.
     * @return true iff the present node is relevant for the parameter regexp
     */
    boolean isActiveFor(final Regexp r);

    /**
     * True iff the present node is a legal termination node for the parameter
     * regexp.
     *
     * @param r A regular expression representation.
     * @return true iff the present node is a legl termination node for the
     * parameter regexp.
     */
    boolean isTerminalFor(final Regexp r);
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

/**
 * The match engine used to make matches.
 */
public interface MatchEngine {

    /**
     * Detect all matches for the input in buffer b, and run all actions
     * associated with the matching regexps.
     *
     * @param b the buffer to search in.
     */
    void match(final Buffer b);
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import java.util.Set;
import no.rmz.rmatch.interfaces.Match;

/**
 * A set used to hold matches that are legal to run since they
 * represent a legal match, but may or may not actually be run pending
 * determination of domination ordering.
 */
public interface RunnableMatchesHolder {

    /**
     * Add a match to the set. Fail if the match isn't final.
     *
     * @param m the match to add.
     */
    void add(final Match m);

    /**
     * Get the set of matches.
     *
     * @return the set of matches.
     */
    Set<Match> getMatches();
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import java.util.Collection;
import java.util.SortedSet;

/**
 * An interface that must be implemented by representations of nondeterminstic
 * finite automaton-nodes. (NDFAs).
 */
public interface NDFANode extends Node, Comparable<NDFANode> {

    /**
     * Epsilon edges are edges that connect nodes without the need to follow
     * any input. This method adds an epsilon edge from the present node
     * to some other node.
     * @param n The node that will be the gtarget of the epsilon edge.
     */
    void addEpsilonEdge(final NDFANode n);

    /**
     * Remove a node that is reachable from this node through an epsilon
     * (no-input) edge.
     *
     * @param n the node to remove.
     */
    void removeEpsilonReachableNode(final NDFANode n);

    /**
     * Get all the nodes that are reachable by epsilon edges.
     * @return All the nodes reachable by epsilon edges.
     */
    SortedSet<NDFANode> getEpsilons();



    /**
     * Give n that the nxt character is ch, what is the next
     * NDFA node that can be reached.  In the particular brand of nondeterminsm
     * implemented by this interface, there will for each outgoingcharacter
     * at most one node that is dreictly reachable through that character.
     * This is very much the common case  for regular expressions, but in the
     * not so uncommon special case where one wants multiple nodes to be
     * reached by the same character, this must be implemente by having
     * an intermeiate noe that is directly reached, and that node then has
     * to have epsilon nodes that reaches the other nodes that are to be
     * reached through the character.
     * @param ch  Get the node reachable through character ch.
     * @return the character to reach through (or something like that).
     */
    NDFANode getNextNDFA(final Character ch);

    /**
     * While getNextNDFA will give the single node that is reachable through
     * a character,  in general there will be more noes that are reached
     * due to the possib
     * e presence of epsilon nodes  going out of the target node found
     * by getNestNDFA.   The getNextSet method will  find the transitive,
     * reflexive
     * closure of the epsilon-reachable nodes going out of the node found by
     * getNextNDFA
     * the character ch.
     * @param ch The character we're lokking through
     * @return The set of nodes reachable thrugh the character ch.
     */
    SortedSet<NDFANode> getNextSet(final Character ch);

    /**
     * The regular expression this node is representing.
     * @return The Regexp this node is part of the representatio of.
     */
    Regexp getRegexp();

    @Override
    boolean isActiveFor(final Regexp rexp);

    /**
     * A collection of edges that can be used when printing a graph. Is not
     * necessarily when actually traversing the graph. Also, an implementation
     * may choose to return null for this method, for efficiency reasons or
     * other reasons.
     *
     * @return A collection of printable edges or null.
     */
    Collection<PrintableEdge> getEdgesToPrint();

    /**
     * If true, then the present node represents a valid termination of a match.
     * This means that a match that is in progress can be returned and executed,
     * because it is a legal match, but not necessarily that it will since there
     * may be other overlapping matches that should be run instead (determined
     * through the "domination protocol").
     *
     * @return iff the node is terminal.
     */
    boolean isTerminal();

    // XXX isTerminalFor and isTerminal is obviously overlapping in
    //     functionality.  This must be cleaned up.  The most obvious
    //     fix is to remove the isTerminalFor method and replace it
    //     with something else.
    @Override
    boolean isTerminalFor(final Regexp rexp);

    /**
     * If the NDFA exececution ever reaches a node for which isFailing is true,
     * the matcher must abandon any matches for the Regexp that which the
     * failing node represents.
     * <p>
     * A typical usecase for this type of node is for inverted matches:
     * "[^abc]".
     *
     * @return True iff this node dictates failing for matches associated with
     * this NDFANode's Regexp.
     */
    boolean isFailing();
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import java.util.Set;

/**
 * Implement the Node interface for deterministic finite automatas (DFA)s.
 * Implement the Node interface for deterministic finite automatas (DFA)s.
 */
public interface DFANode extends Node {

    /**
     * Add a link going out through a character to a specific DFANOde.
     *
     * @param c the linking character
     * @param n the target node
     */
    void addLink(final Character c, final DFANode n);

    /**
     * Add a reference to a regep that is relevant for the present node.
     *
     * @param r a regexp.
     */
    void addRegexp(final Regexp r);

    /**
     * Get the DFAnode we can reach from here through a character.
     *
     * @param ch A character.
     * @param ns NodeStorage A node storage instance used to get new DFA nodes.
     * @return Return a determinstic node.
     */
    DFANode getNext(final Character ch, final NodeStorage ns);

    /**
     * Get the set of regexps that are associated with the present node.
     *
     * @return a set of regexps.
     */
    Set<Regexp> getRegexps();

    /**
     * True iff there is an outgoing link for the character.
     *
     * @param c the character
     * @return true iff there exists an outgoing link
     */
    boolean hasLinkFor(final Character c);

    @Override
    boolean isActiveFor(final Regexp r);

    @Override
    boolean isTerminalFor(final Regexp r);

    /**
     * Create a new match instance and add it to a MatchSet.
     *
     * @param ms A MatchSet.
     * @param r A regular expression.
     * @return A newly created Match.
     */
    Match newMatch(final MatchSet ms, final Regexp r);

    /**
     * Remove a link mapping the character c to somewhere.
     *
     * @param c a character
     */
    void removeLink(final Character c);


    /**
     * True if this DFA node will fail some regexp.
     *
     * @return true iff capable of failing a regexp.
     */
    boolean failsSomeRegexps();

    /**
     * True if this node fails for a particular regesp.
     *
     * @param regexp the regex we may be failing for.
     * @return true iff failing for regexp.
     */
    boolean isFailingFor(final Regexp regexp);

    /**
     * Return an unique long that identifies this DFA in this matcher engine.
     * Mostly intended to be used during debugging, to visualize the graph of the
     * DFA.
     */
    long getId();
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import no.rmz.rmatch.compiler.RegexpParserException;

import java.util.Set;

/**
 * Storage for regular expressions. It provides an interface for storing regular
 * expressions, as strings, and retrieving their corresponding representations
 * as Regexpr instances.
 * <p>
 * The lookup is syntactic, not semantic, so that equivalent regular expression
 * strings, such as "aa*" and "a+" will not be recognized as representing the
 * same regular language, even if they in fact do that.
 */
public interface RegexpStorage {

    /**
     * True iff we have stored a representation corresponding to the regular
     * expression string given as parameter.
     *
     * @param regexp a regular expression string.
     * @return true iff a representation is stored for regexp.
     */
    boolean hasRegexp(final String regexp);

    /**
     * Get the representation representing a regexp string.
     *
     * @param regexp a regular expression string. If no representation is stored
     * prior to the invocation of getRegexp, a representation will be added
     * through the invocation of getRegexp.
     *
     * @return A Regexp instance representing the regexp string.
     */
    Regexp getRegexp(final String regexp);

    /**
     * Add an action associated with a regular expression. If the regular
     * expression isn't represented by a Regexp representation prior to the
     * invocation of the add method, a representation will be created by this
     * invocation.
     *
     * @param regexp A regular expression string.
     * @param a An action to be invoked when the regular expression matches.
     * @throws RegexpParserException when the regexp has a syntax error.
     */
    void add(final String regexp, final Action a) throws RegexpParserException;

    /**
     * Remove the associaten between a regular expression and an action.
     *
     * @param regexp a regular expression
     * @param a An action
     */
    void remove(final String regexp, final Action a);

    /**
     * Get the set of regular expression associated with this storage instance.
     *
     * @return A set of regular expression representations.
     */
    Set<String> getRegexpSet();
}
package no.rmz.rmatch.interfaces;

public interface LookaheadBuffer extends Buffer {

    /**
     * Will return the character that will be read after the current one.
     * @return The next character to be read. If no more characters to be read
     * then return null.
     */
    Character peek();
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import java.util.Comparator;

/**
 * A Match represents a situation where a match has been found for some pattern.
 * There will typically be one or more consumers of the match, and these will
 * have to both extract the pattern that was matched for, and the content from
 * the Buffer being matched over that triggered the match.
 */
public interface Match {

    /**
     * Get the unique identifier for the match.
     *
     * @return an (long) integer uniquely identifying the match.
     */
    long getId();

    /**
     * Abandon this match. Remove all references to it from everything the match
     * knows points to it (the match set and the regexp).
     */
    void abandon(Character currentChar);

    /**
     * True iff the match has been abandoned.
     *
     * @return abandonment status.
     */
    boolean isAbandoned();

    /**
     * The MatchSet instance that contains this match.
     *
     * @return A MatchSet instance
     */
    MatchSet getMatchSet();

    /**
     * Return the Regexp instance that triggered this match.
     *
     * @return a Regexp instance.
     */
    Regexp getRegexp();

    /**
     * Get the index of the last element of the match.
     *
     * @return the index of the last element of the match.
     */
    int getEnd();

    /**
     * Get the index of the first index of the match.
     *
     * @return the index of the last character in the match.
     */
    int getStart();

    /**
     * True iff the match is actively being developed.
     *
     * @return a current activity state.
     */
    boolean isActive();

    /**
     * True iff the match represents a valid termination of the regular
     * expression is being matched.
     *
     * @return iff the current state represents a valid termination state.
     */
    boolean isFinal();

    /**
     * Set the current end position of the match.
     *
     * @param end the end position
     */
    void setEnd(int end);

    /**
     * Set the state if the match to be final.
     */
    void setIsFinal();

    /**
     * Set the state oft he match to be not final.
     */
    void setNotFinal();

    /**
     * Set the state of the match to be inactive.
     */
    void setInactive();

    /**
     * Set the activity state of the match to be whatever.
     *
     * @param activityState the new activity state.
     */
    void setActive(boolean activityState);

    /**
     * Set the finality state to be whatever.
     *
     * @param finalityState the new finality state.
     */
    void setFinal(boolean finalityState);
    /**
     * A comparator that compares matches based on their unique identifier.
     */
    Comparator<Match> COMPARE_BY_OBJECT_ID =
            (t, t1) -> {
                // return Long.signum(t.getId() - t1.getId());
                final long l1 = t.getId();
                final long l2 = t1.getId();
                return Long.compare(l1, l2);
            };
    /**
     * A comparator that compares matches based on their domination status.
     */
    final Comparator<Match> COMPARE_BY_DOMINATION = (final Match ths, final Match that) -> {
        if (ths == that) {
            return 0;
        } else if (ths.getRegexp() != that.getRegexp()) {
            return 0;
        } else if ((ths.getStart() == that.getStart())
                && (ths.getEnd() == that.getEnd())) {
            return 0;
        } else if ((ths.getStart() <= that.getStart())
                && (ths.getEnd() >= that.getEnd())) {
            return -1;
        } else if ((ths.getStart() >= that.getStart())
                && (ths.getEnd() <= that.getEnd())) {
            return 1;
        } else {
            return 0;
        }
    };

    default boolean isZeroLength() {
        return (this.getEnd() - this.getStart()) == 0;
    }

    default boolean notReadyForCommit() {
        return !isFinal() || isActive();
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import java.util.Collection;
import java.util.SortedSet;

/**
 * Implements a "subset construction mechanism". When matching a regular
 * expression, the expression is first compiled into a nondeterministic finite
 * automaton. That automaton is then opportunistically (incrementally, whatever)
 * compiled into a deterministic finite automaton. Now, the number of
 * determinstic nodes is O(2^N) where N is the number of nondeterminstic nodes,
 * so making them all is, for large regular expressions, usually not an option.
 * That is why we are opportunistic and cacheing etc.
 * <p>
 * The NodeStorage is the interface used to abstract this mechanism away.
 */
public interface NodeStorage {

    /**
     * Add a new NDFANode to the startnode associated with the NodeStoarge.
     *
     * @param n a node to add.
     */
    void addToStartnode(final NDFANode n);

    /**
     * Get the determinstic node that represents the beginning of all matches
     * starting from the startnode that begins with the character ch.
     *
     * @param ch an input character.
     * @return a relevant DFANode, or null if no node could be found.
     */
    DFANode getNextFromStartNode(final Character ch);

    /**
     * Given a set of NDFANodes, return a DFANode representing that set of
     * NDFANOdes.
     *
     * @param ndfaset A set of nondeterminstic nodes we want to represent with a
     * single deterministic node.
     * @return A new deterministic node representing the input.
     */
    DFANode getDFANode(final SortedSet<NDFANode> ndfaset);

    /**
     * Get a snapshot of the currently stored NDFANodes.
     *
     * @return All the NDFANodes know to the NodeStorage.
     */
    Collection<NDFANode> getNDFANodes();

    /**
     * Get a snapshot of the currently stored DFAodes.
     *
     * @return All the NDFANodes know to the NodeStorage.
     */
    Collection<DFANode> getDFANodes();
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import no.rmz.rmatch.impls.DominationHeap;

/**
 * A representation of a regular expression. Regexps are comparable to each
 * other, but essentially that is just comparison of the regexp strings.
 */
public interface Regexp extends Comparable<Regexp> {


    /**
     * Remove all references that the regexp has to the match m.
     *
     * @param m the match to remove references to.
     */
    void abandonMatch(final Match m, final Character currentChar);

    /**
     * Add an action to a regexp.
     *
     * @param a the action.
     */
    void add(final Action a);

    /**
     * Add a node and treat it as active.
     *
     * @param n the node to check for.
     */
    // XXX This should be DFA nodes. It never happens for NDFAs.
    void addActive(final Node n);

    /**
     * Allow a node to be treated as terminal.
     *
     * @param n a node
     */
    void addTerminalNode(final Node n);  // Can be both N and D FA.

    /**
     * Add all the matches that are not dominated to the set of runnable
     * matches.
     *
     * @param runnableMatches A holder of matches.
     */
    void commitUndominated(final RunnableMatchesHolder runnableMatches);


    /**
     * Get a domination heap for a MatchSet.
     *
     * @param ms the MatchSet
     * @return the corresponding DominationHeap.
     */
    DominationHeap getDominationHeapCreateIfNotPresent(final MatchSet ms);

    /**
     * Remove all references to a particular MatchSet, and the matches within
     * it.
     *
     * @param ms a MatchSet instance..
     */
    void abandonMatchSet(final MatchSet ms);

    /**
     * Get the NDFANode representing the start state for the NDFA that will
     * match this regular expression.
     *
     * @return the node representing this regexp.
     */
    NDFANode getMyNode();

    /**
     * A string representing the same regexp as the Regexp instance.
     *
     * @return the regexp string for this regular expression.
     */
    String getRexpString();

    /**
     * True iff the the regexp has actions.
     *
     * @param a an action
     * @return true if the action is associated with the regexp.
     */
    // XXX Only for testing, should be moved to implementation class.
    boolean hasAction(final Action a);

    /**
     * True iff the regexp has any actions (if it doesn't it can be ignored
     * since it can have no observable impact).
     *
     * @return true iff the regexp has any actions associated with it.
     */
    boolean hasActions();

    /**
     * True iff there are matches associated with this regexp.
     *
     * @return True iff there are matches associated with the regexp.
     */
    boolean hasMatches(); // XXX  Bogus?

    /**
     * True if a node is active for this regexp.
     *
     * @param n a node
     * @return true iff ithe node is active for the Regexp.
     */
    boolean isActiveFor(final Node n);

    /**
     * True iff the regexp has been compiled into an NDFA.
     *
     * @return true iff the regex is compiled to an ndfa.
     */
    boolean isCompiled();

    /**
     * True iff a match is dominating over all other matches for this regexp.
     *
     * @param m the match
     * @return is it dominating?
     */
    boolean isDominating(final Match m);

    /**
     * True iff the the node is terminal for this regexp.
     *
     * @param n the node.
     * @return true iff n is terminal for this regexp.
     */
    boolean hasTerminalNdfaNode(final Node n);

    /**
     * True iff the match is strongly dominated XXX Whatever that is!!
     *
     * @param m a match
     * @return true iff strongly dominated.
     */
    boolean isStronglyDominated(Match m);

    /**
     * Perform all actions on a buffer with a start a end location.
     *
     * @param b     the buffer
     * @param start the start location
     * @param end   the end location
     */
    void performActions(final Buffer b, final int start, final int end);

    /**
     * Register a match with this regexp.
     *
     * @param m a match that is registred with this regexp.
     */
    void registerMatch(final Match m);

    /**
     * Remove an action from this regexp.
     *
     * @param a removing an action from this regexp.
     */
    void remove(final Action a);

    /**
     * Set the compilation result to be an NDFA Node representing this regexp.
     *
     * @param myNode The NDFA node representing the entry point for the NDFA
     *               representing the regexp.
     */
    void setMyNDFANode(final NDFANode myNode);

    /**
     * True if the regexp is associated with a particular match. For testing use
     * only (XXX So it should be removed to the implementation class and used
     * from there only).
     *
     * @param m a match
     * @return true iff the match is associated with this regexp.
     */
    boolean hasMatch(final Match m);
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

/**
 * The action interface is used when a match is identified, and the results of
 * it must be communicated to the outside world.
 */
public interface Action {

    /**
     * When a match is found, actions corresponding to that match is
     * triggered.
     * <p>
     * An instance that can perform a match action must implement this
     * interface.
     *
     * @param b The buffer where the match occurred.
     * @param start The first position of the buffer that matches.
     * @param end The last position in the buffer that matches.
     */
    void performMatch(final Buffer b, final int start, final int end);
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import no.rmz.rmatch.compiler.RegexpParserException;

/**
 * A compiler for regular expressions.
 */
public interface NDFACompiler {

    /**
     * Compile a regular expression, using a RegexpStorage, and return an
     * NDFANode instance that represents the entry point for the compiled
     * expression.
     *
     * @param regexp A regular expression.
     * @param rs A regexp storage.
     * @return An NDFANode that will match the regexp.
     * @throws RegexpParserException when the regexp doesn't parse.
     */
    NDFANode compile(final Regexp regexp, final RegexpStorage rs)
            throws RegexpParserException;
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

/**
 * Buffers are the basic way to get access to the input being parsed.
 */
public interface Buffer extends Comparable<Buffer> {

    /**
     * Return everything in the Buffer from, but not including the current
     * character as a string. XXX This may be useful for testing, but shouldn't
     * be i the main interface!
     *
     * @return the string representing the rest of the buffer.
     */
    @Deprecated
    String getCurrentRestString();

    /**
     * We need some way to get the content of the matches out, and this is one
     * way of doing it.
     *
     * @param start the first character of the substring to return.
     * @param stop The last character of the substring to return.
     * @return part of the buffer's content.
     */
    String getString(final int start, final int stop);

    /**
     * Are there any more characters after the current one?
     *
     * @return true iff more characters are available
     */
    boolean hasNext();

    /**
     * Get the next character.
     *
     * @return the next character.
     */
    Character getNext();

    /**
     * Get the current position in the buffer, to be used when getting strings
     * representing matches.
     *
     * @return an integer representing the position in a buffer.
     */
    int getCurrentPos(); // XXX Should this be a long?

    /**
     * Return a copy of the present buffer that can be modified without
     * modifying the state of the cloned original.
     *
     * @return A cloned buffer.
     */
    Buffer clone();


    private static int compoundCompare(int... results) {
        for (int result : results) {
            if (result != 0) {
                return result;
            }
        }
        return 0;
    }

    @Override
    default int compareTo(Buffer other) {
        return compoundCompare(
        Integer.compare(this.getCurrentPos(), other.getCurrentPos()),
                this.getString(0, this.getCurrentPos()).compareTo(other.getString(0, other.getCurrentPos())),
                Boolean.compare(this.hasNext(), other.hasNext()));
    }
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import java.util.Comparator;
import java.util.Set;

/**
 * A set of matches that is being processed by a matcher. The set of matches all
 * start at the same position in the input but may end at different positions.
 */
public interface MatchSet {


    /**
     * XXX Not really sure what this method does.  Review and report back.
     * @param target the recipient of matches that are committed.
     */
    void finalCommit(final RunnableMatchesHolder target);

    /**
     * Get all of the matches that are currently associated with the MatchSet.
     *
     * @return a set of Match instances.
     */
    Set<Match> getMatches();

    /**
     * The start position for all the matches in the input.
     *
     * @return a start position.
     */
    int getStart();

    /**
     * True if there are any matches in this MatchSet.
     * @return do we have any matches?
     */
    boolean hasMatches();

    /**
     * An identifier that uniquely identifies the match set.
     *
     * @return an id.
     */
    long getId();

    /**
     * Will progress the match-set one character ahead. All the matches that
     * can be continued will be continued, and those that can't will be aborted.
     * The matches that can be correctly terminated will be added to the set of
     * runnable matches through the runnableMatches instance, but only those
     * matches that is the "dominant" one will eventually run, the others will
     * be discarded silently.
     *
     * @param ns A node storage instance used to get new DFA nodes.
     * @param currentChar The current char.
     * @param currentPos The current position.
     * @param runnableMatches The set of runnable matches.
     */
    void progress(
            final NodeStorage ns,
            final Character currentChar,
            final int currentPos,
            final RunnableMatchesHolder runnableMatches);

    /**
     * Remove a match from the MatchSet instance.
     *
     * @param m a match.
     */
    void removeMatch(final Match m);
    /**
     * A comparator for match sets. Match sets are equal iff they have the same
     * identifier.
     */
    Comparator<MatchSet> COMPARE_BY_ID =
 (final MatchSet t, final MatchSet t1) -> {
                final long l1 = t.getId();
                final long l2 = t1.getId();

     return Long.compare(l1, l2);
            };
}
/**
 * Copyright 2012. Bjørn Remseth (rmz@rmz.no).
 * <p>
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package no.rmz.rmatch.interfaces;

import static com.google.common.base.Preconditions.*;
import no.rmz.rmatch.impls.RegexpImpl;

/**
 * A producer of regexp instances. This is an useful interface to have when
 * testing various things. In production the default DEFAULT_REGEXP_FACTORY will
 * be used all the time.
 */
public interface RegexpFactory {

    /**
     * Generate a new regular expression instance.
     *
     * @param regexpString A string that will be interpreted as a regular
     * expression.
     * @return A Regexp instance.
     */
    Regexp newRegexp(final String regexpString);
    /**
     * The default regexp factory that is used in production. It works by making
     * a RegexpImpl instance.
     */
    RegexpFactory DEFAULT_REGEXP_FACTORY = (final String regexpString) -> {
        checkNotNull(regexpString, "regexpString can't be null");
        return new RegexpImpl(regexpString);
    };
}
